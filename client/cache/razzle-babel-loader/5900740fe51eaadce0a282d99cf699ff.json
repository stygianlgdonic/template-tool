{"ast":null,"code":"var _jsxFileName = \"D:\\\\dev\\\\hyper-engage\\\\web\\\\src\\\\Screens\\\\CreateCardLayout\\\\components\\\\DesignTool\\\\Components\\\\Card\\\\MainCanvas\\\\MainStage\\\\index.tsx\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { useRef, useState } from 'react';\nimport { Stage, Layer, Rect } from 'react-konva';\nimport Rectangle from \"../Rectangle\";\nimport UCircle from \"../UCircle\";\nimport UPolygon from \"../UPolygon\";\nimport ULine from \"../ULine\";\nimport USvg from \"../USvg\";\nimport UText from \"../UText\";\nimport TransformerComponent from \"../UTransformer\";\nimport { stageDimensions } from '../../../../../../../../utils/defaults';\nimport UImage from '../UImage';\n\nconst MainStage = ({\n  templateData,\n  setTemplateData,\n  variationIndex,\n  selectedId,\n  setSelectedId,\n  unSelectAll,\n  handleEditSelectedItem\n}) => {\n  var _templateData$variati, _templateData$variati2, _templateData$variati3, _templateData$variati4, _templateData$variati5, _templateData$variati6, _templateData$variati7, _templateData$variati8, _templateData$variati9, _templateData$variati10, _templateData$variati11;\n\n  const GUIDELINE_OFFSET = 5;\n  const $stage = useRef(null);\n  const $layer = useRef(null);\n  const $tr = useRef(null);\n  const selectionRectRef = useRef(null);\n  const selection = useRef({\n    visible: false,\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0\n  });\n  const {\n    0: nodesArray,\n    1: setNodes\n  } = useState([]);\n  const Konva = window.Konva;\n\n  const getLineGuideStops = skipShape => {\n    const vertical = [0, stageDimensions.width / 2, stageDimensions.width];\n    const horizontal = [0, stageDimensions.height / 2, stageDimensions.height]; // and we snap over edges and center of each object on the canvas\n\n    $stage.current.find(\".object\").forEach(guideItem => {\n      if (guideItem === skipShape) {\n        return;\n      }\n\n      const box = guideItem.getClientRect(); // and we can snap to all edges of shapes\n\n      vertical.push([box.x, box.x + box.width, box.x + box.width / 2]);\n      horizontal.push([box.y, box.y + box.height, box.y + box.height / 2]);\n    });\n    return {\n      vertical: vertical.flat(),\n      horizontal: horizontal.flat()\n    };\n  };\n\n  const getObjectSnappingEdges = node => {\n    const box = node.getClientRect();\n    return {\n      vertical: [{\n        guide: Math.round(box.x),\n        offset: Math.round(node.x() - box.x),\n        snap: \"start\"\n      }, {\n        guide: Math.round(box.x + box.width / 2),\n        offset: Math.round(node.x() - box.x - box.width / 2),\n        snap: \"center\"\n      }, {\n        guide: Math.round(box.x + box.width),\n        offset: Math.round(node.x() - box.x - box.width),\n        snap: \"end\"\n      }],\n      horizontal: [{\n        guide: Math.round(box.y),\n        offset: Math.round(node.y() - box.y),\n        snap: \"start\"\n      }, {\n        guide: Math.round(box.y + box.height / 2),\n        offset: Math.round(node.y() - box.y - box.height / 2),\n        snap: \"center\"\n      }, {\n        guide: Math.round(box.y + box.height),\n        offset: Math.round(node.y() - box.y - box.height),\n        snap: \"end\"\n      }]\n    };\n  };\n\n  const getGuides = (lineGuideStops, itemBounds) => {\n    const resultV = [];\n    const resultH = [];\n    lineGuideStops.vertical.forEach(lineGuide => {\n      itemBounds.vertical.forEach(itemBound => {\n        const diff = Math.abs(lineGuide - itemBound.guide); // if the distance between guild line and object snap point is close we can consider this for snapping\n\n        if (diff < GUIDELINE_OFFSET) {\n          resultV.push({\n            lineGuide: lineGuide,\n            diff: diff,\n            snap: itemBound.snap,\n            offset: itemBound.offset\n          });\n        }\n      });\n    });\n    lineGuideStops.horizontal.forEach(lineGuide => {\n      itemBounds.horizontal.forEach(itemBound => {\n        const diff = Math.abs(lineGuide - itemBound.guide);\n\n        if (diff < GUIDELINE_OFFSET) {\n          resultH.push({\n            lineGuide: lineGuide,\n            diff: diff,\n            snap: itemBound.snap,\n            offset: itemBound.offset\n          });\n        }\n      });\n    });\n    const guides = []; // find closest snap\n\n    const minV = resultV.sort((a, b) => a.diff - b.diff)[0];\n    const minH = resultH.sort((a, b) => a.diff - b.diff)[0];\n\n    if (minV) {\n      guides.push({\n        lineGuide: minV.lineGuide,\n        offset: minV.offset,\n        orientation: \"V\",\n        snap: minV.snap\n      });\n    }\n\n    if (minH) {\n      guides.push({\n        lineGuide: minH.lineGuide,\n        offset: minH.offset,\n        orientation: \"H\",\n        snap: minH.snap\n      });\n    }\n\n    return guides;\n  };\n\n  const drawGuides = guides => {\n    guides.forEach(lg => {\n      if (lg.orientation === \"H\") {\n        const lines = new Konva.Line({\n          points: [-6000, lg.lineGuide, 6000, lg.lineGuide],\n          stroke: \"rgb(0, 161, 255)\",\n          strokeWidth: 1,\n          name: \"guid-line\",\n          dash: [4, 6]\n        });\n        $layer.current.add(lines);\n        $layer.current.batchDraw();\n      } else if (lg.orientation === \"V\") {\n        const lines = new Konva.Line({\n          points: [lg.lineGuide, -6000, lg.lineGuide, 6000],\n          stroke: \"rgb(0, 161, 255)\",\n          strokeWidth: 1,\n          name: \"guid-line\",\n          dash: [4, 6]\n        });\n        $layer.current.add(lines);\n        $layer.current.batchDraw();\n      }\n    });\n  };\n\n  const _onDragMove = e => {\n    const linesArray = $layer.current.find(\".guid-line\");\n\n    if (!!linesArray.length) {\n      linesArray.forEach(item => item.destroy());\n    }\n\n    const lineGuideStops = getLineGuideStops(e.target);\n    const itemBounds = getObjectSnappingEdges(e.target);\n    const guides = getGuides(lineGuideStops, itemBounds);\n\n    if (!guides.length) {\n      return;\n    }\n\n    drawGuides(guides);\n    guides.forEach(lg => {\n      switch (lg.snap) {\n        case \"start\":\n          {\n            switch (lg.orientation) {\n              case \"V\":\n                {\n                  e.target.x(lg.lineGuide + lg.offset);\n                  break;\n                }\n\n              case \"H\":\n                {\n                  e.target.y(lg.lineGuide + lg.offset);\n                  break;\n                }\n\n              default:\n                return;\n            }\n\n            break;\n          }\n\n        case \"center\":\n          {\n            switch (lg.orientation) {\n              case \"V\":\n                {\n                  e.target.x(lg.lineGuide + lg.offset);\n                  break;\n                }\n\n              case \"H\":\n                {\n                  e.target.y(lg.lineGuide + lg.offset);\n                  break;\n                }\n\n              default:\n                return;\n            }\n\n            break;\n          }\n\n        case \"end\":\n          {\n            switch (lg.orientation) {\n              case \"V\":\n                {\n                  e.target.x(lg.lineGuide + lg.offset);\n                  break;\n                }\n\n              case \"H\":\n                {\n                  e.target.y(lg.lineGuide + lg.offset);\n                  break;\n                }\n\n              default:\n                return;\n            }\n\n            break;\n          }\n\n        default:\n          return;\n      }\n    });\n  };\n\n  const _onDragEnd = e => {\n    const linesArray = $layer.current.find(\".guid-line\");\n\n    if (!!linesArray.length) {\n      linesArray.forEach(item => item.destroy());\n    }\n\n    $layer.current.batchDraw();\n  };\n\n  const checkDeselect = e => {\n    // deselect when clicked on empty area\n    const clickedOnEmpty = e.target === e.target.getStage();\n\n    if (clickedOnEmpty) {\n      unSelectAll();\n      $tr.current.nodes([]);\n      setNodes([]); // layerRef.current.remove(selectionRectangle);\n    }\n  };\n\n  const updateSelectionRect = () => {\n    const node = selectionRectRef.current;\n    node.setAttrs({\n      visible: selection.current.visible,\n      x: Math.min(selection.current.x1, selection.current.x2),\n      y: Math.min(selection.current.y1, selection.current.y2),\n      width: Math.abs(selection.current.x1 - selection.current.x2),\n      height: Math.abs(selection.current.y1 - selection.current.y2),\n      fill: \"rgba(0, 161, 255, 0.3)\"\n    });\n    node.getLayer().batchDraw();\n  };\n\n  const oldPos = React.useRef(null);\n\n  const onMouseDown = e => {\n    const isElement = e.target.findAncestor(\".elements-container\");\n    const isTransformer = e.target.findAncestor(\"Transformer\");\n\n    if (isElement || isTransformer) {\n      return;\n    }\n\n    const pos = e.target.getStage().getPointerPosition();\n    selection.current.visible = true;\n    selection.current.x1 = pos.x;\n    selection.current.y1 = pos.y;\n    selection.current.x2 = pos.x;\n    selection.current.y2 = pos.y;\n    updateSelectionRect();\n  };\n\n  const onMouseMove = e => {\n    if (!selection.current.visible) {\n      return;\n    }\n\n    const pos = e.target.getStage().getPointerPosition();\n    selection.current.x2 = pos.x;\n    selection.current.y2 = pos.y;\n    updateSelectionRect();\n  };\n\n  const onMouseUp = () => {\n    oldPos.current = null;\n\n    if (!selection.current.visible) {\n      return;\n    }\n\n    const selBox = selectionRectRef.current.getClientRect();\n    const elements = [];\n    $layer.current.find(\".object\").forEach(elementNode => {\n      const elBox = elementNode.getClientRect();\n\n      if (Konva.Util.haveIntersection(selBox, elBox)) {\n        elements.push(elementNode);\n      }\n    });\n    $tr.current.nodes(elements);\n    selection.current.visible = false; // disable click event\n\n    Konva.listenClickTap = false;\n    updateSelectionRect();\n  };\n\n  const onClickTap = e => {\n    // if we are selecting with rect, do nothing\n    if (selectionRectRef.current.visible()) {\n      return;\n    }\n\n    let stage = e.target.getStage();\n    let layer = $layer.current;\n    let tr = $tr.current; // if click on empty area - remove all selections\n\n    if (e.target === stage) {\n      unSelectAll();\n      setNodes([]);\n      tr.nodes([]);\n      layer.draw();\n      return;\n    } // do nothing if clicked NOT on our rectangles\n\n\n    if (!e.target.hasName(\".object\")) {\n      return;\n    } // do we pressed shift or ctrl?\n\n\n    const metaPressed = e.evt.shiftKey || e.evt.ctrlKey || e.evt.metaKey;\n    const isSelected = tr.nodes().indexOf(e.target) >= 0;\n\n    if (!metaPressed && !isSelected) {\n      // if no key pressed and the node is not selected\n      // select just one\n      tr.nodes([e.target]);\n    } else if (metaPressed && isSelected) {\n      // if we pressed keys and node was selected\n      // we need to remove it from selection:\n      const nodes = tr.nodes().slice(); // use slice to have new copy of array\n      // remove node from array\n\n      nodes.splice(nodes.indexOf(e.target), 1);\n      tr.nodes(nodes);\n    } else if (metaPressed && !isSelected) {\n      // add the node into selection\n      const nodes = tr.nodes().concat([e.target]);\n      tr.nodes(nodes);\n    }\n\n    layer.draw();\n  };\n\n  console.log({\n    templateData\n  });\n  return __jsx(Stage, _extends({\n    ref: $stage,\n    onMouseDown: onMouseDown,\n    onMouseUp: onMouseUp,\n    onMouseMove: onMouseMove,\n    onTouchStart: checkDeselect,\n    onClick: onClickTap\n  }, stageDimensions, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 378,\n      columnNumber: 9\n    }\n  }), __jsx(Layer, {\n    ref: $layer,\n    onDragMove: _onDragMove,\n    onDragEnd: _onDragEnd,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 387,\n      columnNumber: 13\n    }\n  }, templateData === null || templateData === void 0 ? void 0 : (_templateData$variati = templateData.variations[variationIndex].shapes) === null || _templateData$variati === void 0 ? void 0 : (_templateData$variati2 = _templateData$variati.filter(item => item.type === \"rectangle\")) === null || _templateData$variati2 === void 0 ? void 0 : _templateData$variati2.map((rect, i) => {\n    return __jsx(Rectangle, {\n      key: i,\n      shapeProps: rect,\n      onSelect: e => {\n        if (e.current !== undefined) {\n          let temp = nodesArray;\n          if (!nodesArray.includes(e.current)) temp.push(e.current);\n          setNodes(temp);\n          $tr.current.nodes(nodesArray);\n          $tr.current.nodes(nodesArray);\n          $tr.current.getLayer().batchDraw();\n        }\n\n        setSelectedId(rect.id);\n      } // onSelect={() => {\n      //     setSelectedId(rect.id)\n      // }}\n      ,\n      onEditClick: handleEditSelectedItem,\n      onChange: newAttrs => {\n        setTemplateData(prev => {\n          const index = prev.variations[variationIndex].shapes.findIndex(item => item.id === rect.id);\n          prev.variations[variationIndex].shapes[index] = newAttrs;\n        });\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 394,\n        columnNumber: 25\n      }\n    });\n  }), templateData === null || templateData === void 0 ? void 0 : (_templateData$variati3 = templateData.variations[variationIndex].shapes) === null || _templateData$variati3 === void 0 ? void 0 : (_templateData$variati4 = _templateData$variati3.filter(item => item.type === \"circle\")) === null || _templateData$variati4 === void 0 ? void 0 : _templateData$variati4.map((circle, i) => {\n    return __jsx(UCircle, {\n      key: i,\n      shapeProps: circle,\n      onSelect: () => {\n        setSelectedId(circle.id);\n      },\n      onEditClick: handleEditSelectedItem,\n      onChange: newAttrs => {\n        setTemplateData(prev => {\n          const index = prev.variations[variationIndex].shapes.findIndex(item => item.id === circle.id);\n          prev.variations[variationIndex].shapes[index] = newAttrs;\n        });\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 423,\n        columnNumber: 25\n      }\n    });\n  }), templateData === null || templateData === void 0 ? void 0 : (_templateData$variati5 = templateData.variations[variationIndex].shapes) === null || _templateData$variati5 === void 0 ? void 0 : (_templateData$variati6 = _templateData$variati5.filter(item => item.type === \"line\")) === null || _templateData$variati6 === void 0 ? void 0 : _templateData$variati6.map((line, i) => {\n    return __jsx(ULine, {\n      key: i,\n      shapeProps: line,\n      onSelect: () => {\n        setSelectedId(line.id);\n      },\n      onEditClick: handleEditSelectedItem,\n      onChange: newAttrs => {\n        setTemplateData(prev => {\n          const index = prev.variations[variationIndex].shapes.findIndex(item => item.id === line.id);\n          prev.variations[variationIndex].shapes[index] = newAttrs;\n        });\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 441,\n        columnNumber: 25\n      }\n    });\n  }), templateData === null || templateData === void 0 ? void 0 : (_templateData$variati7 = templateData.variations[variationIndex].shapes) === null || _templateData$variati7 === void 0 ? void 0 : (_templateData$variati8 = _templateData$variati7.filter(item => item.type === \"polygon\")) === null || _templateData$variati8 === void 0 ? void 0 : _templateData$variati8.map((polygon, i) => {\n    return __jsx(UPolygon, {\n      key: i,\n      shapeProps: polygon,\n      onSelect: () => {\n        setSelectedId(polygon.id);\n      },\n      onEditClick: handleEditSelectedItem,\n      onChange: newAttrs => {\n        setTemplateData(prev => {\n          const index = prev.variations[variationIndex].shapes.findIndex(item => item.id === polygon.id);\n          prev.variations[variationIndex].shapes[index] = newAttrs;\n        });\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 459,\n        columnNumber: 25\n      }\n    });\n  }), templateData === null || templateData === void 0 ? void 0 : (_templateData$variati9 = templateData.variations[variationIndex].svgs) === null || _templateData$variati9 === void 0 ? void 0 : _templateData$variati9.map((item, index) => __jsx(USvg, {\n    key: index,\n    svgProps: item,\n    onSelect: () => {\n      setSelectedId(item.id);\n    },\n    onEditClick: handleEditSelectedItem,\n    onChange: event => setTemplateData(prev => {\n      prev.variations[variationIndex].svgs[index] = _objectSpread(_objectSpread({}, prev.variations[variationIndex].svgs[index]), JSON.parse(JSON.stringify(event.target.attrs)));\n    }),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 476,\n      columnNumber: 21\n    }\n  })), templateData === null || templateData === void 0 ? void 0 : (_templateData$variati10 = templateData.variations[variationIndex].images) === null || _templateData$variati10 === void 0 ? void 0 : _templateData$variati10.map((item, index) => __jsx(UImage, {\n    key: index,\n    imageProps: item,\n    onSelect: () => {\n      setSelectedId(item.id);\n    },\n    onChange: event => setTemplateData(prev => {\n      prev.variations[variationIndex].images[index] = _objectSpread(_objectSpread({}, prev.variations[variationIndex].images[index]), JSON.parse(JSON.stringify(event.target.attrs)));\n    }),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 492,\n      columnNumber: 21\n    }\n  })), templateData === null || templateData === void 0 ? void 0 : (_templateData$variati11 = templateData.variations[variationIndex].textBoxes) === null || _templateData$variati11 === void 0 ? void 0 : _templateData$variati11.map((item, index) => __jsx(UText, {\n    key: index,\n    textProps: item,\n    onSelect: () => {\n      setSelectedId(item.id);\n    },\n    onEditClick: handleEditSelectedItem,\n    onChange: event => setTemplateData(prev => {\n      prev.variations[variationIndex].textBoxes[index] = _objectSpread({}, event.target.attrs);\n    }),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 507,\n      columnNumber: 21\n    }\n  })), __jsx(TransformerComponent, {\n    id: `tr${selectedId}`,\n    $tr: $tr,\n    selectedShapeName: selectedId,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 519,\n      columnNumber: 17\n    }\n  }), __jsx(Rect, {\n    fill: \"rgba(0,0,255,0.5)\",\n    ref: selectionRectRef,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 524,\n      columnNumber: 17\n    }\n  })));\n};\n\nexport default MainStage;","map":{"version":3,"sources":["D:/dev/hyper-engage/web/src/Screens/CreateCardLayout/components/DesignTool/Components/Card/MainCanvas/MainStage/index.tsx"],"names":["React","useRef","useState","Stage","Layer","Rect","Rectangle","UCircle","UPolygon","ULine","USvg","UText","TransformerComponent","stageDimensions","UImage","MainStage","templateData","setTemplateData","variationIndex","selectedId","setSelectedId","unSelectAll","handleEditSelectedItem","GUIDELINE_OFFSET","$stage","$layer","$tr","selectionRectRef","selection","visible","x1","y1","x2","y2","nodesArray","setNodes","Konva","window","getLineGuideStops","skipShape","vertical","width","horizontal","height","current","find","forEach","guideItem","box","getClientRect","push","x","y","flat","getObjectSnappingEdges","node","guide","Math","round","offset","snap","getGuides","lineGuideStops","itemBounds","resultV","resultH","lineGuide","itemBound","diff","abs","guides","minV","sort","a","b","minH","orientation","drawGuides","lg","lines","Line","points","stroke","strokeWidth","name","dash","add","batchDraw","_onDragMove","e","linesArray","length","item","destroy","target","_onDragEnd","checkDeselect","clickedOnEmpty","getStage","nodes","updateSelectionRect","setAttrs","min","fill","getLayer","oldPos","onMouseDown","isElement","findAncestor","isTransformer","pos","getPointerPosition","onMouseMove","onMouseUp","selBox","elements","elementNode","elBox","Util","haveIntersection","listenClickTap","onClickTap","stage","layer","tr","draw","hasName","metaPressed","evt","shiftKey","ctrlKey","metaKey","isSelected","indexOf","slice","splice","concat","console","log","variations","shapes","filter","type","map","rect","i","undefined","temp","includes","id","newAttrs","prev","index","findIndex","circle","line","polygon","svgs","event","JSON","parse","stringify","attrs","images","textBoxes"],"mappings":"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","sourcesContent":["import React, { useRef, useState } from 'react'\r\nimport { Stage, Layer, Rect } from 'react-konva';\r\nimport Rectangle from \"../Rectangle\"\r\nimport UCircle from \"../UCircle\"\r\nimport UPolygon from \"../UPolygon\"\r\nimport ULine from \"../ULine\"\r\nimport USvg from \"../USvg\"\r\nimport UText from \"../UText\"\r\nimport TransformerComponent from \"../UTransformer\"\r\nimport { stageDimensions } from '../../../../../../../../utils/defaults';\r\nimport UImage from '../UImage';\r\n\r\ndeclare const window: any\r\n\r\nconst MainStage = ({\r\n    templateData,\r\n    setTemplateData,\r\n    variationIndex,\r\n    selectedId,\r\n    setSelectedId,\r\n    unSelectAll,\r\n    handleEditSelectedItem,\r\n}) => {\r\n\r\n    const GUIDELINE_OFFSET = 5\r\n    const $stage = useRef(null)\r\n    const $layer = useRef(null)\r\n    const $tr = useRef(null)\r\n    const selectionRectRef = useRef(null);\r\n    const selection = useRef({\r\n        visible: false,\r\n        x1: 0,\r\n        y1: 0,\r\n        x2: 0,\r\n        y2: 0\r\n    });\r\n\r\n    const [nodesArray, setNodes] = useState([]);\r\n    const Konva = window.Konva;\r\n\r\n    const getLineGuideStops = skipShape => {\r\n        const vertical: any = [0, stageDimensions.width / 2, stageDimensions.width];\r\n        const horizontal: any = [0, stageDimensions.height / 2, stageDimensions.height];\r\n\r\n        // and we snap over edges and center of each object on the canvas\r\n        $stage.current.find(\".object\").forEach(guideItem => {\r\n            if (guideItem === skipShape) {\r\n                return;\r\n            }\r\n            const box = guideItem.getClientRect();\r\n            // and we can snap to all edges of shapes\r\n            vertical.push([box.x, box.x + box.width, box.x + box.width / 2]);\r\n            horizontal.push([box.y, box.y + box.height, box.y + box.height / 2]);\r\n        });\r\n        return {\r\n            vertical: vertical.flat(),\r\n            horizontal: horizontal.flat()\r\n        };\r\n    };\r\n\r\n    const getObjectSnappingEdges = node => {\r\n        const box = node.getClientRect();\r\n\r\n        return {\r\n            vertical: [\r\n                {\r\n                    guide: Math.round(box.x),\r\n                    offset: Math.round(node.x() - box.x),\r\n                    snap: \"start\"\r\n                },\r\n                {\r\n                    guide: Math.round(box.x + box.width / 2),\r\n                    offset: Math.round(node.x() - box.x - box.width / 2),\r\n                    snap: \"center\"\r\n                },\r\n                {\r\n                    guide: Math.round(box.x + box.width),\r\n                    offset: Math.round(node.x() - box.x - box.width),\r\n                    snap: \"end\"\r\n                }\r\n            ],\r\n            horizontal: [\r\n                {\r\n                    guide: Math.round(box.y),\r\n                    offset: Math.round(node.y() - box.y),\r\n                    snap: \"start\"\r\n                },\r\n                {\r\n                    guide: Math.round(box.y + box.height / 2),\r\n                    offset: Math.round(node.y() - box.y - box.height / 2),\r\n                    snap: \"center\"\r\n                },\r\n                {\r\n                    guide: Math.round(box.y + box.height),\r\n                    offset: Math.round(node.y() - box.y - box.height),\r\n                    snap: \"end\"\r\n                }\r\n            ]\r\n        };\r\n    };\r\n\r\n    const getGuides = (lineGuideStops, itemBounds) => {\r\n        const resultV = [];\r\n        const resultH = [];\r\n\r\n        lineGuideStops.vertical.forEach(lineGuide => {\r\n            itemBounds.vertical.forEach(itemBound => {\r\n                const diff = Math.abs(lineGuide - itemBound.guide);\r\n                // if the distance between guild line and object snap point is close we can consider this for snapping\r\n                if (diff < GUIDELINE_OFFSET) {\r\n                    resultV.push({\r\n                        lineGuide: lineGuide,\r\n                        diff: diff,\r\n                        snap: itemBound.snap,\r\n                        offset: itemBound.offset\r\n                    });\r\n                }\r\n            });\r\n        });\r\n\r\n        lineGuideStops.horizontal.forEach(lineGuide => {\r\n            itemBounds.horizontal.forEach(itemBound => {\r\n                const diff = Math.abs(lineGuide - itemBound.guide);\r\n                if (diff < GUIDELINE_OFFSET) {\r\n                    resultH.push({\r\n                        lineGuide: lineGuide,\r\n                        diff: diff,\r\n                        snap: itemBound.snap,\r\n                        offset: itemBound.offset\r\n                    });\r\n                }\r\n            });\r\n        });\r\n\r\n        const guides = [];\r\n\r\n        // find closest snap\r\n        const minV = resultV.sort((a, b) => a.diff - b.diff)[0];\r\n        const minH = resultH.sort((a, b) => a.diff - b.diff)[0];\r\n        if (minV) {\r\n            guides.push({\r\n                lineGuide: minV.lineGuide,\r\n                offset: minV.offset,\r\n                orientation: \"V\",\r\n                snap: minV.snap\r\n            });\r\n        }\r\n        if (minH) {\r\n            guides.push({\r\n                lineGuide: minH.lineGuide,\r\n                offset: minH.offset,\r\n                orientation: \"H\",\r\n                snap: minH.snap\r\n            });\r\n        }\r\n        return guides;\r\n    };\r\n\r\n    const drawGuides = guides => {\r\n        guides.forEach(lg => {\r\n            if (lg.orientation === \"H\") {\r\n                const lines = new Konva.Line({\r\n                    points: [-6000, lg.lineGuide, 6000, lg.lineGuide],\r\n                    stroke: \"rgb(0, 161, 255)\",\r\n                    strokeWidth: 1,\r\n                    name: \"guid-line\",\r\n                    dash: [4, 6]\r\n                });\r\n                $layer.current.add(lines);\r\n                $layer.current.batchDraw();\r\n            } else if (lg.orientation === \"V\") {\r\n                const lines = new Konva.Line({\r\n                    points: [lg.lineGuide, -6000, lg.lineGuide, 6000],\r\n                    stroke: \"rgb(0, 161, 255)\",\r\n                    strokeWidth: 1,\r\n                    name: \"guid-line\",\r\n                    dash: [4, 6]\r\n                });\r\n                $layer.current.add(lines);\r\n                $layer.current.batchDraw();\r\n            }\r\n        });\r\n    };\r\n\r\n    const _onDragMove = e => {\r\n        const linesArray = $layer.current.find(\".guid-line\")\r\n        if (!!linesArray.length) {\r\n            linesArray.forEach(item => item.destroy())\r\n        }\r\n        const lineGuideStops = getLineGuideStops(e.target);\r\n        const itemBounds = getObjectSnappingEdges(e.target);\r\n        const guides = getGuides(lineGuideStops, itemBounds);\r\n        if (!guides.length) {\r\n            return;\r\n        }\r\n        drawGuides(guides);\r\n        guides.forEach(lg => {\r\n            switch (lg.snap) {\r\n                case \"start\": {\r\n                    switch (lg.orientation) {\r\n                        case \"V\": {\r\n                            e.target.x(lg.lineGuide + lg.offset);\r\n                            break;\r\n                        }\r\n                        case \"H\": {\r\n                            e.target.y(lg.lineGuide + lg.offset);\r\n                            break;\r\n                        }\r\n                        default:\r\n                            return;\r\n                    }\r\n                    break;\r\n                }\r\n                case \"center\": {\r\n                    switch (lg.orientation) {\r\n                        case \"V\": {\r\n                            e.target.x(lg.lineGuide + lg.offset);\r\n                            break;\r\n                        }\r\n                        case \"H\": {\r\n                            e.target.y(lg.lineGuide + lg.offset);\r\n                            break;\r\n                        }\r\n                        default:\r\n                            return;\r\n                    }\r\n                    break;\r\n                }\r\n                case \"end\": {\r\n                    switch (lg.orientation) {\r\n                        case \"V\": {\r\n                            e.target.x(lg.lineGuide + lg.offset);\r\n                            break;\r\n                        }\r\n                        case \"H\": {\r\n                            e.target.y(lg.lineGuide + lg.offset);\r\n                            break;\r\n                        }\r\n                        default:\r\n                            return;\r\n                    }\r\n                    break;\r\n                }\r\n                default:\r\n                    return;\r\n            }\r\n        });\r\n    };\r\n\r\n    const _onDragEnd = e => {\r\n        const linesArray = $layer.current.find(\".guid-line\")\r\n        if (!!linesArray.length) {\r\n            linesArray.forEach(item => item.destroy())\r\n        }\r\n        $layer.current.batchDraw();\r\n    };\r\n\r\n    const checkDeselect = (e) => {\r\n        // deselect when clicked on empty area\r\n        const clickedOnEmpty = e.target === e.target.getStage();\r\n        if (clickedOnEmpty) {\r\n            unSelectAll();\r\n            $tr.current.nodes([]);\r\n            setNodes([]);\r\n            // layerRef.current.remove(selectionRectangle);\r\n        }\r\n    };\r\n\r\n    const updateSelectionRect = () => {\r\n        const node = selectionRectRef.current;\r\n        node.setAttrs({\r\n            visible: selection.current.visible,\r\n            x: Math.min(selection.current.x1, selection.current.x2),\r\n            y: Math.min(selection.current.y1, selection.current.y2),\r\n            width: Math.abs(selection.current.x1 - selection.current.x2),\r\n            height: Math.abs(selection.current.y1 - selection.current.y2),\r\n            fill: \"rgba(0, 161, 255, 0.3)\"\r\n        });\r\n        node.getLayer().batchDraw();\r\n    };\r\n\r\n    const oldPos = React.useRef(null);\r\n    const onMouseDown = (e) => {\r\n        const isElement = e.target.findAncestor(\".elements-container\");\r\n        const isTransformer = e.target.findAncestor(\"Transformer\");\r\n        if (isElement || isTransformer) {\r\n            return;\r\n        }\r\n\r\n        const pos = e.target.getStage().getPointerPosition();\r\n        selection.current.visible = true;\r\n        selection.current.x1 = pos.x;\r\n        selection.current.y1 = pos.y;\r\n        selection.current.x2 = pos.x;\r\n        selection.current.y2 = pos.y;\r\n        updateSelectionRect();\r\n    };\r\n\r\n    const onMouseMove = (e) => {\r\n        if (!selection.current.visible) {\r\n            return;\r\n        }\r\n        const pos = e.target.getStage().getPointerPosition();\r\n        selection.current.x2 = pos.x;\r\n        selection.current.y2 = pos.y;\r\n        updateSelectionRect();\r\n    };\r\n\r\n    const onMouseUp = () => {\r\n        oldPos.current = null;\r\n        if (!selection.current.visible) {\r\n            return;\r\n        }\r\n        const selBox = selectionRectRef.current.getClientRect();\r\n\r\n        const elements = [];\r\n        $layer.current.find(\".object\").forEach((elementNode) => {\r\n            const elBox = elementNode.getClientRect();\r\n            if (Konva.Util.haveIntersection(selBox, elBox)) {\r\n                elements.push(elementNode);\r\n            }\r\n        });\r\n        $tr.current.nodes(elements);\r\n        selection.current.visible = false;\r\n        // disable click event\r\n        Konva.listenClickTap = false;\r\n        updateSelectionRect();\r\n    };\r\n\r\n    const onClickTap = (e) => {\r\n        // if we are selecting with rect, do nothing\r\n        if (selectionRectRef.current.visible()) {\r\n            return;\r\n        }\r\n        let stage = e.target.getStage();\r\n        let layer = $layer.current;\r\n        let tr = $tr.current;\r\n        // if click on empty area - remove all selections\r\n        if (e.target === stage) {\r\n            unSelectAll();\r\n            setNodes([]);\r\n            tr.nodes([]);\r\n            layer.draw();\r\n            return;\r\n        }\r\n\r\n        // do nothing if clicked NOT on our rectangles\r\n        if (!e.target.hasName(\".object\")) {\r\n            return;\r\n        }\r\n\r\n        // do we pressed shift or ctrl?\r\n        const metaPressed = e.evt.shiftKey || e.evt.ctrlKey || e.evt.metaKey;\r\n        const isSelected = tr.nodes().indexOf(e.target) >= 0;\r\n\r\n        if (!metaPressed && !isSelected) {\r\n            // if no key pressed and the node is not selected\r\n            // select just one\r\n            tr.nodes([e.target]);\r\n        } else if (metaPressed && isSelected) {\r\n            // if we pressed keys and node was selected\r\n            // we need to remove it from selection:\r\n            const nodes = tr.nodes().slice(); // use slice to have new copy of array\r\n            // remove node from array\r\n            nodes.splice(nodes.indexOf(e.target), 1);\r\n            tr.nodes(nodes);\r\n        } else if (metaPressed && !isSelected) {\r\n            // add the node into selection\r\n            const nodes = tr.nodes().concat([e.target]);\r\n            tr.nodes(nodes);\r\n        }\r\n        layer.draw();\r\n    };\r\n\r\n    console.log({ templateData })\r\n\r\n    return (\r\n        <Stage\r\n            ref={$stage}\r\n            onMouseDown={onMouseDown}\r\n            onMouseUp={onMouseUp}\r\n            onMouseMove={onMouseMove}\r\n            onTouchStart={checkDeselect}\r\n            onClick={onClickTap}\r\n            {...stageDimensions}\r\n        >\r\n            <Layer\r\n                ref={$layer}\r\n                onDragMove={_onDragMove}\r\n                onDragEnd={_onDragEnd}\r\n            >\r\n                {templateData?.variations[variationIndex].shapes?.filter(item => item.type === \"rectangle\")?.map((rect, i) => {\r\n                    return (\r\n                        <Rectangle\r\n                            key={i}\r\n                            shapeProps={rect}\r\n                            onSelect={(e) => {\r\n                                if (e.current !== undefined) {\r\n                                    let temp = nodesArray;\r\n                                    if (!nodesArray.includes(e.current)) temp.push(e.current);\r\n                                    setNodes(temp);\r\n                                    $tr.current.nodes(nodesArray);\r\n                                    $tr.current.nodes(nodesArray);\r\n                                    $tr.current.getLayer().batchDraw();\r\n                                }\r\n                                setSelectedId(rect.id);\r\n                            }}\r\n                            // onSelect={() => {\r\n                            //     setSelectedId(rect.id)\r\n                            // }}\r\n                            onEditClick={handleEditSelectedItem}\r\n                            onChange={(newAttrs) => {\r\n                                setTemplateData((prev) => {\r\n                                    const index = prev.variations[variationIndex].shapes.findIndex(item => item.id === rect.id)\r\n                                    prev.variations[variationIndex].shapes[index] = newAttrs\r\n                                });\r\n                            }}\r\n                        />\r\n                    );\r\n                })}\r\n                {templateData?.variations[variationIndex].shapes?.filter(item => item.type === \"circle\")?.map((circle, i) => {\r\n                    return (\r\n                        <UCircle\r\n                            key={i}\r\n                            shapeProps={circle}\r\n                            onSelect={() => {\r\n                                setSelectedId(circle.id)\r\n                            }}\r\n                            onEditClick={handleEditSelectedItem}\r\n                            onChange={(newAttrs) => {\r\n                                setTemplateData((prev) => {\r\n                                    const index = prev.variations[variationIndex].shapes.findIndex(item => item.id === circle.id)\r\n                                    prev.variations[variationIndex].shapes[index] = newAttrs\r\n                                });\r\n                            }}\r\n                        />\r\n                    );\r\n                })}\r\n                {templateData?.variations[variationIndex].shapes?.filter(item => item.type === \"line\")?.map((line, i) => {\r\n                    return (\r\n                        <ULine\r\n                            key={i}\r\n                            shapeProps={line}\r\n                            onSelect={() => {\r\n                                setSelectedId(line.id)\r\n                            }}\r\n                            onEditClick={handleEditSelectedItem}\r\n                            onChange={(newAttrs) => {\r\n                                setTemplateData((prev) => {\r\n                                    const index = prev.variations[variationIndex].shapes.findIndex(item => item.id === line.id)\r\n                                    prev.variations[variationIndex].shapes[index] = newAttrs\r\n                                });\r\n                            }}\r\n                        />\r\n                    );\r\n                })}\r\n                {templateData?.variations[variationIndex].shapes?.filter(item => item.type === \"polygon\")?.map((polygon, i) => {\r\n                    return (\r\n                        <UPolygon\r\n                            key={i}\r\n                            shapeProps={polygon}\r\n                            onSelect={() => {\r\n                                setSelectedId(polygon.id)\r\n                            }}\r\n                            onEditClick={handleEditSelectedItem}\r\n                            onChange={(newAttrs) => {\r\n                                setTemplateData((prev) => {\r\n                                    const index = prev.variations[variationIndex].shapes.findIndex(item => item.id === polygon.id)\r\n                                    prev.variations[variationIndex].shapes[index] = newAttrs\r\n                                });\r\n                            }}\r\n                        />\r\n                    );\r\n                })}\r\n                {templateData?.variations[variationIndex].svgs?.map((item, index) => (\r\n                    <USvg\r\n                        key={index}\r\n                        svgProps={item}\r\n                        onSelect={() => {\r\n                            setSelectedId(item.id)\r\n                        }}\r\n                        onEditClick={handleEditSelectedItem}\r\n                        onChange={(event) => setTemplateData((prev) => {\r\n                            prev.variations[variationIndex].svgs[index] = {\r\n                                ...prev.variations[variationIndex].svgs[index],\r\n                                ...JSON.parse(JSON.stringify(event.target.attrs))\r\n                            }\r\n                        })}\r\n                    />\r\n                ))}\r\n                {templateData?.variations[variationIndex].images?.map((item, index) => (\r\n                    <UImage\r\n                        key={index}\r\n                        imageProps={item}\r\n                        onSelect={() => {\r\n                            setSelectedId(item.id)\r\n                        }}\r\n                        onChange={(event) => setTemplateData((prev) => {\r\n                            prev.variations[variationIndex].images[index] = {\r\n                                ...prev.variations[variationIndex].images[index],\r\n                                ...JSON.parse(JSON.stringify(event.target.attrs))\r\n                            }\r\n                        })}\r\n                    />\r\n                ))}\r\n                {templateData?.variations[variationIndex].textBoxes?.map((item, index) => (\r\n                    <UText\r\n                        key={index}\r\n                        textProps={item}\r\n                        onSelect={() => {\r\n                            setSelectedId(item.id)\r\n                        }}\r\n                        onEditClick={handleEditSelectedItem}\r\n                        onChange={(event) => setTemplateData((prev) => {\r\n                            prev.variations[variationIndex].textBoxes[index] = { ...event.target.attrs }\r\n                        })}\r\n                    />\r\n                ))}\r\n                <TransformerComponent\r\n                    id={`tr${selectedId}`}\r\n                    $tr={$tr}\r\n                    selectedShapeName={selectedId}\r\n                />\r\n                <Rect fill=\"rgba(0,0,255,0.5)\" ref={selectionRectRef} />\r\n            </Layer>\r\n        </Stage>\r\n    )\r\n}\r\n\r\nexport default MainStage\r\n"]},"metadata":{},"sourceType":"module"}