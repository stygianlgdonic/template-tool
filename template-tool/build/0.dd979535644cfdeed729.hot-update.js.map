{"version":3,"file":"0.dd979535644cfdeed729.hot-update.js","sources":["webpack:///./src/components/DesignTool/MainStage/index.tsx"],"sourcesContent":["import React, { useRef, useState } from 'react'\r\nimport { Stage, Layer, Rect } from 'react-konva';\r\nimport Rectangle from \"../Rectangle\"\r\nimport UCircle from \"../UCircle\"\r\nimport UPolygon from \"../UPolygon\"\r\nimport ULine from \"../ULine\"\r\nimport USvg from \"../USvg\"\r\nimport UText from \"../UText\"\r\nimport TransformerComponent from \"../UTransformer\"\r\nimport UImage from '../UImage';\r\n\r\ndeclare const window: any\r\n\r\nconst MainStage = ({\r\n    templateData,\r\n    setTemplateData,\r\n    variationIndex,\r\n    selectedId,\r\n    setSelectedId,\r\n    unSelectAll,\r\n    handleEditSelectedItem,\r\n}) => {\r\n\r\n    const $stage = useRef(null)\r\n    const $layer = useRef(null)\r\n    const $tr = useRef(null)\r\n    // snapping distance\r\n    const GUIDELINE_OFFSET = 10\r\n    const selectionRectRef = useRef(null);\r\n    const selection = useRef({\r\n        visible: false,\r\n        x1: 0,\r\n        y1: 0,\r\n        x2: 0,\r\n        y2: 0\r\n    });\r\n\r\n    const [nodesArray, setNodes] = useState([]);\r\n    const Konva = window.Konva;\r\n\r\n    const getLineGuideStops = skipShape => {\r\n        // guidelines for stage center and edges\r\n        const vertical: any = [0, (templateData.dimensions.width) / 2, (templateData.dimensions.width)];\r\n        const horizontal: any = [0, (templateData.dimensions.height) / 2, (templateData.dimensions.height)];\r\n\r\n        // we snap over edges and center of each object on the canvas\r\n        $stage.current.find(\".object\").forEach(guideItem => {\r\n            if (guideItem === skipShape) {\r\n                return;\r\n            }\r\n\r\n            // const isWrapped = $tr.current?.nodes()?.some(node => node.attrs.id === guideItem.attrs.id)\r\n            // if (isWrapped) return\r\n            // console.log({ skipShape, guideItem, isWrapped })\r\n\r\n            const box = guideItem.getClientRect();\r\n            // we can snap to all edges of shapes\r\n            vertical.push([box.x, box.x + box.width, box.x + box.width / 2]);\r\n            horizontal.push([box.y, box.y + box.height, box.y + box.height / 2]);\r\n        });\r\n        return {\r\n            vertical: vertical.flat(),\r\n            horizontal: horizontal.flat()\r\n        };\r\n    };\r\n\r\n    // getting snapping edges for elements on the Stage\r\n    const getObjectSnappingEdges = node => {\r\n        const box = node.getClientRect();\r\n\r\n        return {\r\n            vertical: [\r\n                {\r\n                    guide: Math.round(box.x),\r\n                    offset: Math.round(node.x() - box.x),\r\n                    snap: \"start\"\r\n                },\r\n                {\r\n                    guide: Math.round(box.x + box.width / 2),\r\n                    offset: Math.round(node.x() - box.x - box.width / 2),\r\n                    snap: \"center\"\r\n                },\r\n                {\r\n                    guide: Math.round(box.x + box.width),\r\n                    offset: Math.round(node.x() - box.x - box.width),\r\n                    snap: \"end\"\r\n                }\r\n            ],\r\n            horizontal: [\r\n                {\r\n                    guide: Math.round(box.y),\r\n                    offset: Math.round(node.y() - box.y),\r\n                    snap: \"start\"\r\n                },\r\n                {\r\n                    guide: Math.round(box.y + box.height / 2),\r\n                    offset: Math.round(node.y() - box.y - box.height / 2),\r\n                    snap: \"center\"\r\n                },\r\n                {\r\n                    guide: Math.round(box.y + box.height),\r\n                    offset: Math.round(node.y() - box.y - box.height),\r\n                    snap: \"end\"\r\n                }\r\n            ]\r\n        };\r\n    };\r\n\r\n    // getting all guidelines for snapping by calculating if the item bounds are close to the guidlinestop\r\n    const getGuides = (lineGuideStops, itemBounds) => {\r\n        const resultV = [];\r\n        const resultH = [];\r\n\r\n        lineGuideStops.vertical.forEach(lineGuide => {\r\n            itemBounds.vertical.forEach(itemBound => {\r\n                const diff = Math.abs(lineGuide - itemBound.guide);\r\n                // if the distance between guild line and object snap point is close we can consider this for snapping\r\n                if (diff < GUIDELINE_OFFSET) {\r\n                    resultV.push({\r\n                        lineGuide: lineGuide,\r\n                        diff: diff,\r\n                        snap: itemBound.snap,\r\n                        offset: itemBound.offset\r\n                    });\r\n                }\r\n            });\r\n        });\r\n\r\n        lineGuideStops.horizontal.forEach(lineGuide => {\r\n            itemBounds.horizontal.forEach(itemBound => {\r\n                const diff = Math.abs(lineGuide - itemBound.guide);\r\n                // if the distance between guild line and object snap point is close we can consider this for snapping\r\n                if (diff < GUIDELINE_OFFSET) {\r\n                    resultH.push({\r\n                        lineGuide: lineGuide,\r\n                        diff: diff,\r\n                        snap: itemBound.snap,\r\n                        offset: itemBound.offset\r\n                    });\r\n                }\r\n            });\r\n        });\r\n\r\n        const guides = [];\r\n\r\n        // find closest snap\r\n        const minV = resultV?.sort((a, b) => a.diff - b.diff)[0];\r\n        const minH = resultH?.sort((a, b) => a.diff - b.diff)[0];\r\n        if (minV) {\r\n            guides.push({\r\n                lineGuide: minV.lineGuide,\r\n                offset: minV.offset,\r\n                orientation: \"V\",\r\n                snap: minV.snap\r\n            });\r\n        }\r\n        if (minH) {\r\n            guides.push({\r\n                lineGuide: minH.lineGuide,\r\n                offset: minH.offset,\r\n                orientation: \"H\",\r\n                snap: minH.snap\r\n            });\r\n        }\r\n        return guides;\r\n    };\r\n\r\n    // drawing guidelines on stage\r\n    const drawGuides = guides => {\r\n        guides.forEach(lg => {\r\n            if (lg.orientation === \"H\") {\r\n                const lines = new Konva.Line({\r\n                    points: [-6000, lg.lineGuide, 6000, lg.lineGuide],\r\n                    stroke: \"rgb(0, 161, 255)\",\r\n                    strokeWidth: 1,\r\n                    name: \"guid-line\",\r\n                    dash: [4, 6]\r\n                });\r\n                $layer.current.add(lines);\r\n                $layer.current.batchDraw();\r\n            } else if (lg.orientation === \"V\") {\r\n                const lines = new Konva.Line({\r\n                    points: [lg.lineGuide, -6000, lg.lineGuide, 6000],\r\n                    stroke: \"rgb(0, 161, 255)\",\r\n                    strokeWidth: 1,\r\n                    name: \"guid-line\",\r\n                    dash: [4, 6]\r\n                });\r\n                $layer.current.add(lines);\r\n                $layer.current.batchDraw();\r\n            }\r\n        });\r\n    };\r\n\r\n    // when dragging any element snap element if its close to snap guideline\r\n    const _onDragMove = e => {\r\n        const linesArray = $layer.current.find(\".guid-line\")\r\n        if (!!linesArray.length) {\r\n            linesArray.forEach(item => item.destroy())\r\n        }\r\n        const lineGuideStops = getLineGuideStops(e.target);\r\n\r\n        // Need to snap transformer not shape\r\n        const itemBounds = getObjectSnappingEdges(e.target);\r\n        const guides = getGuides(lineGuideStops, itemBounds);\r\n        if (!guides.length) {\r\n            return;\r\n        }\r\n\r\n        // const isWrapped = $tr.current?.nodes()?.some(node => node.attrs.id === e.target.attrs.id)\r\n        // if (isWrapped) return\r\n\r\n        drawGuides(guides);\r\n        guides.forEach(lg => {\r\n            switch (lg.snap) {\r\n                case \"start\": {\r\n                    switch (lg.orientation) {\r\n                        case \"V\": {\r\n                            e.target.x(lg.lineGuide + lg.offset);\r\n                            break;\r\n                        }\r\n                        case \"H\": {\r\n                            e.target.y(lg.lineGuide + lg.offset);\r\n                            break;\r\n                        }\r\n                        default:\r\n                            return;\r\n                    }\r\n                    break;\r\n                }\r\n                case \"center\": {\r\n                    switch (lg.orientation) {\r\n                        case \"V\": {\r\n                            e.target.x(lg.lineGuide + lg.offset);\r\n                            break;\r\n                        }\r\n                        case \"H\": {\r\n                            e.target.y(lg.lineGuide + lg.offset);\r\n                            break;\r\n                        }\r\n                        default:\r\n                            return;\r\n                    }\r\n                    break;\r\n                }\r\n                case \"end\": {\r\n                    switch (lg.orientation) {\r\n                        case \"V\": {\r\n                            e.target.x(lg.lineGuide + lg.offset);\r\n                            break;\r\n                        }\r\n                        case \"H\": {\r\n                            e.target.y(lg.lineGuide + lg.offset);\r\n                            break;\r\n                        }\r\n                        default:\r\n                            return;\r\n                    }\r\n                    break;\r\n                }\r\n                default:\r\n                    return;\r\n            }\r\n        });\r\n    };\r\n\r\n    // on drag end remove all guidelines from the stage\r\n    const _onDragEnd = e => {\r\n        const linesArray = $layer.current.find(\".guid-line\")\r\n        if (!!linesArray.length) {\r\n            linesArray.forEach(item => item.destroy())\r\n        }\r\n        $layer.current.batchDraw();\r\n    };\r\n\r\n    // const checkDeselect = (e) => {\r\n    //     // deselect when clicked on empty area\r\n    //     const clickedOnEmpty = e.target === e.target.getStage();\r\n    //     if (clickedOnEmpty) {\r\n    //         setSelectedId(null);\r\n    //         $tr.current.nodes([]);\r\n    //         setNodes([]);\r\n    //         // layerRef.current.remove(selectionRectangle);\r\n    //     }\r\n    // };\r\n\r\n    const updateSelectionRect = () => {\r\n        const node = selectionRectRef.current;\r\n        // while mouseDrag update the selection rect accordingly \r\n        node.setAttrs({\r\n            visible: selection.current.visible,\r\n            x: Math.min(selection.current.x1, selection.current.x2),\r\n            y: Math.min(selection.current.y1, selection.current.y2),\r\n            width: Math.abs(selection.current.x1 - selection.current.x2),\r\n            height: Math.abs(selection.current.y1 - selection.current.y2),\r\n            fill: \"rgba(0, 161, 255, 0.3)\"\r\n        });\r\n        node.getLayer().batchDraw();\r\n    };\r\n\r\n    const oldPos = React.useRef(null);\r\n    const onMouseDown = (e) => {\r\n        const isElement = e.target.attrs.id !== \"shapes_background\";\r\n        const isTransformer = e.target.findAncestor(\"Transformer\");\r\n\r\n        // If clicked thing is Element or Transformer then don't detach the transformer from the element(s)\r\n        if (isElement || isTransformer) {\r\n            return;\r\n        }\r\n\r\n        // Draw selection box\r\n        const pos = e.target.getStage().getPointerPosition();\r\n        selection.current.visible = true;\r\n        selection.current.x1 = pos.x;\r\n        selection.current.y1 = pos.y;\r\n        selection.current.x2 = pos.x;\r\n        selection.current.y2 = pos.y;\r\n        updateSelectionRect();\r\n    };\r\n\r\n    const onMouseMove = (e) => {\r\n        if (!selection.current.visible) {\r\n            return;\r\n        }\r\n        const pos = e.target.getStage().getPointerPosition();\r\n        selection.current.x2 = pos.x;\r\n        selection.current.y2 = pos.y;\r\n        updateSelectionRect();\r\n    };\r\n\r\n    const onMouseUp = () => {\r\n        oldPos.current = null;\r\n        if (!selection.current.visible) {\r\n            return;\r\n        }\r\n        const selBox = selectionRectRef.current.getClientRect();\r\n\r\n        // selecting all elements which have intersection with the selection box\r\n        const elements = [];\r\n        $layer.current.find(\".object\").forEach((elementNode) => {\r\n            const elBox = elementNode.getClientRect();\r\n            if (Konva.Util.haveIntersection(selBox, elBox)) {\r\n                elements.push(elementNode);\r\n            }\r\n        });\r\n        // passing all selected elements to transformer\r\n        $tr.current.nodes(elements);\r\n        setNodes(elements)\r\n\r\n        // NOTE - if only one node is within group setSelectedId for that element\r\n        if (elements?.length === 1) {\r\n            setSelectedId(elements[0].attrs.id)\r\n        } else {\r\n            setSelectedId(null)\r\n        }\r\n\r\n        selection.current.visible = false;\r\n        // disable click event\r\n        Konva.listenClickTap = false;\r\n        updateSelectionRect();\r\n    };\r\n\r\n    // \r\n    // const onClickTap = (e) => {\r\n    //     // if we are selecting with rect, do nothing\r\n    //     if (selectionRectRef.current.visible()) {\r\n    //         return;\r\n    //     }\r\n    //     let stage = e.target.getStage();\r\n    //     let layer = $layer.current;\r\n    //     let tr = $tr.current;\r\n    //     // if click on empty area - remove all selections\r\n    //     if (e.target.attrs.id === stage) {\r\n    //         setSelectedId(null);\r\n    //         setNodes([]);\r\n    //         tr.nodes([]);\r\n    //         layer.draw();\r\n    //         return;\r\n    //     }\r\n\r\n    //     // do nothing if clicked NOT on our rectangles\r\n    //     if (!e.target.hasName(\".object\")) {\r\n    //         return;\r\n    //     }\r\n\r\n    //     // do we pressed shift or ctrl?\r\n    //     const metaPressed = e.evt.shiftKey || e.evt.ctrlKey || e.evt.metaKey;\r\n    //     const isSelected = tr.nodes().indexOf(e.target) >= 0;\r\n\r\n    //     if (!metaPressed && !isSelected) {\r\n    //         // if no key pressed and the node is not selected\r\n    //         // select just one\r\n    //         tr.nodes([e.target]);\r\n    //     } else if (metaPressed && isSelected) {\r\n    //         // if we pressed keys and node was selected\r\n    //         // we need to remove it from selection:\r\n    //         const nodes = tr.nodes().slice(); // use slice to have new copy of array\r\n    //         // remove node from array\r\n    //         nodes.splice(nodes.indexOf(e.target), 1);\r\n    //         tr.nodes(nodes);\r\n    //     } else if (metaPressed && !isSelected) {\r\n    //         // add the node into selection\r\n    //         const nodes = tr.nodes().concat([e.target]);\r\n    //         tr.nodes(nodes);\r\n    //     }\r\n    //     layer.draw();\r\n    // };\r\n\r\n    console.log({ templateData })\r\n\r\n    return (\r\n        <Stage\r\n            ref={$stage}\r\n            onMouseDown={onMouseDown}\r\n            onMouseUp={onMouseUp}\r\n            onMouseMove={onMouseMove}\r\n            // onTouchStart={checkDeselect}\r\n            // onClick={onClickTap}\r\n            width={templateData.dimensions.width}\r\n            height={templateData.dimensions.height}\r\n        >\r\n            <Layer\r\n                ref={$layer}\r\n                onDragMove={_onDragMove}\r\n                onDragEnd={_onDragEnd}\r\n            >\r\n                {templateData.variations[variationIndex].elements?.map((elem, i) => {\r\n                    if (elem.type === \"rectangle\") return (\r\n                        <Rectangle\r\n                            key={i}\r\n                            shapeProps={elem}\r\n                            onSelect={(e) => {\r\n                                if (e.current !== undefined) {\r\n                                    let temp = nodesArray;\r\n                                    if (!nodesArray.includes(e.current)) temp.push(e.current);\r\n                                    setNodes(temp);\r\n                                    $tr.current.nodes(nodesArray);\r\n                                    $tr.current.nodes(nodesArray);\r\n                                    $tr.current.getLayer().batchDraw();\r\n                                }\r\n                                if (elem.id !== \"shapes_background\")\r\n                                    setSelectedId(elem.id);\r\n                            }}\r\n                            // onSelect={() => {\r\n                            //     setSelectedId(rect.id)\r\n                            // }}\r\n                            onEditClick={handleEditSelectedItem}\r\n                            onChange={(newAttrs) => {\r\n                                setTemplateData((prev) => {\r\n                                    const index = prev.variations[variationIndex].elements.findIndex(item => item.id === elem.id)\r\n                                    prev.variations[variationIndex].elements[index] = newAttrs\r\n                                });\r\n                            }}\r\n                        />\r\n                    )\r\n\r\n                    if (elem.type === \"circle\") return (\r\n                        <UCircle\r\n                            key={i}\r\n                            shapeProps={elem}\r\n                            onSelect={() => {\r\n                                setSelectedId(elem.id)\r\n                            }}\r\n                            onEditClick={handleEditSelectedItem}\r\n                            onChange={(newAttrs) => {\r\n                                setTemplateData((prev) => {\r\n                                    const index = prev.variations[variationIndex].elements.findIndex(item => item.id === elem.id)\r\n                                    prev.variations[variationIndex].elements[index] = newAttrs\r\n                                });\r\n                            }}\r\n                        />\r\n                    )\r\n\r\n                    if (elem.type === \"line\") return (\r\n                        <ULine\r\n                            key={i}\r\n                            shapeProps={elem}\r\n                            onSelect={() => {\r\n                                setSelectedId(elem.id)\r\n                            }}\r\n                            onEditClick={handleEditSelectedItem}\r\n                            onChange={(newAttrs) => {\r\n                                setTemplateData((prev) => {\r\n                                    const index = prev.variations[variationIndex].elements.findIndex(item => item.id === elem.id)\r\n                                    prev.variations[variationIndex].elements[index] = newAttrs\r\n                                });\r\n                            }}\r\n                        />\r\n                    )\r\n\r\n                    if (elem.type === \"polygon\") return (\r\n                        <UPolygon\r\n                            key={i}\r\n                            shapeProps={elem}\r\n                            onSelect={() => {\r\n                                setSelectedId(elem.id)\r\n                            }}\r\n                            onEditClick={handleEditSelectedItem}\r\n                            onChange={(newAttrs) => {\r\n                                setTemplateData((prev) => {\r\n                                    const index = prev.variations[variationIndex].elements.findIndex(item => item.id === elem.id)\r\n                                    prev.variations[variationIndex].elements[index] = newAttrs\r\n                                });\r\n                            }}\r\n                        />\r\n                    )\r\n\r\n                    if (elem.type === \"svg\") return (\r\n                        <USvg\r\n                            key={i}\r\n                            svgProps={elem}\r\n                            onSelect={() => {\r\n                                setSelectedId(elem.id)\r\n                            }}\r\n                            onEditClick={handleEditSelectedItem}\r\n                            onChange={(event) => setTemplateData((prev) => {\r\n                                const svgIndex = prev.variations[variationIndex].elements.findIndex(svgItem => svgItem.id === elem.id)\r\n                                prev.variations[variationIndex].elements[svgIndex] = {\r\n                                    ...prev.variations[variationIndex].elements[svgIndex],\r\n                                    ...JSON.parse(JSON.stringify(event.target.attrs))\r\n                                }\r\n                            })}\r\n                        />\r\n                    )\r\n\r\n                    if (elem.type === \"image\") return (\r\n                        <UImage\r\n                            key={i}\r\n                            imageProps={elem}\r\n                            onSelect={() => {\r\n                                setSelectedId(elem.id)\r\n                            }}\r\n                            onChange={(event) => setTemplateData((prev) => {\r\n                                const imageIndex = prev.variations[variationIndex].elements.findIndex(img => img.id === elem.id)\r\n                                prev.variations[variationIndex].elements[imageIndex] = {\r\n                                    ...prev.variations[variationIndex].elements[imageIndex],\r\n                                    ...JSON.parse(JSON.stringify(event.target.attrs))\r\n                                }\r\n                            })}\r\n                        />\r\n                    )\r\n\r\n                    if (elem.type === \"text\") return (\r\n                        <UText\r\n                            key={i}\r\n                            textProps={elem}\r\n                            onSelect={() => {\r\n                                setSelectedId(elem.id)\r\n                            }}\r\n                            onEditClick={handleEditSelectedItem}\r\n                            onChange={(event) => setTemplateData((prev) => {\r\n                                const txtIndex = prev.variations[variationIndex].elements.findIndex(txt => txt.id === elem.id)\r\n                                prev.variations[variationIndex].elements[txtIndex] = { ...event.target.attrs }\r\n                            })}\r\n                        />\r\n                    )\r\n\r\n\r\n                })}\r\n\r\n                <TransformerComponent\r\n                    id={`tr${selectedId}`}\r\n                    $tr={$tr}\r\n                    selectedShapeName={selectedId}\r\n                    templateData={templateData}\r\n                />\r\n                <Rect fill=\"rgba(0,0,255,0.5)\" ref={selectionRectRef} />\r\n            </Layer>\r\n        </Stage>\r\n    )\r\n}\r\n\r\nexport default MainStage\r\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAQA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAHA;AAMA;AAEA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAHA;AA7BA;AAoCA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAVA;AACA;AAWA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAVA;AACA;AAWA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAVA;AACA;AAWA;AACA;AACA;AAAA;AACA;AA/CA;AAiDA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AANA;AAOA;AACA;AARA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AACA;AACA;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AAjBA;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AAxBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA4BA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;AAGA;AACA;AACA;AACA;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;;;;A","sourceRoot":""}