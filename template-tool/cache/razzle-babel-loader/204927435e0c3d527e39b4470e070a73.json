{"ast":null,"code":"var _jsxFileName = \"D:\\\\dev\\\\cardclan-backend\\\\template-tool\\\\src\\\\components\\\\DesignTool\\\\MainStage\\\\index.tsx\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { useRef, useState } from 'react';\nimport { Stage, Layer, Rect } from 'react-konva';\nimport Rectangle from \"../Rectangle\";\nimport UCircle from \"../UCircle\";\nimport UPolygon from \"../UPolygon\";\nimport ULine from \"../ULine\";\nimport USvg from \"../USvg\";\nimport UText from \"../UText\";\nimport TransformerComponent from \"../UTransformer\";\nimport { stageDimensions } from '../../../utils/defaults';\nimport UImage from '../UImage';\n\nconst MainStage = ({\n  templateData,\n  setTemplateData,\n  variationIndex,\n  selectedId,\n  setSelectedId,\n  unSelectAll,\n  handleEditSelectedItem\n}) => {\n  var _templateData$variati, _templateData$variati2, _templateData$variati3;\n\n  const GUIDELINE_OFFSET = 5;\n  const $stage = useRef(null);\n  const $layer = useRef(null);\n  const $tr = useRef(null);\n  const selectionRectRef = useRef(null);\n  const selection = useRef({\n    visible: false,\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0\n  });\n  const {\n    0: nodesArray,\n    1: setNodes\n  } = useState([]);\n  const Konva = window.Konva;\n\n  const getLineGuideStops = skipShape => {\n    const vertical = [0, stageDimensions.width / 2, stageDimensions.width];\n    const horizontal = [0, stageDimensions.height / 2, stageDimensions.height]; // and we snap over edges and center of each object on the canvas\n\n    $stage.current.find(\".object\").forEach(guideItem => {\n      if (guideItem === skipShape) {\n        return;\n      }\n\n      const box = guideItem.getClientRect(); // and we can snap to all edges of shapes\n\n      vertical.push([box.x, box.x + box.width, box.x + box.width / 2]);\n      horizontal.push([box.y, box.y + box.height, box.y + box.height / 2]);\n    });\n    return {\n      vertical: vertical.flat(),\n      horizontal: horizontal.flat()\n    };\n  };\n\n  const getObjectSnappingEdges = node => {\n    const box = node.getClientRect();\n    return {\n      vertical: [{\n        guide: Math.round(box.x),\n        offset: Math.round(node.x() - box.x),\n        snap: \"start\"\n      }, {\n        guide: Math.round(box.x + box.width / 2),\n        offset: Math.round(node.x() - box.x - box.width / 2),\n        snap: \"center\"\n      }, {\n        guide: Math.round(box.x + box.width),\n        offset: Math.round(node.x() - box.x - box.width),\n        snap: \"end\"\n      }],\n      horizontal: [{\n        guide: Math.round(box.y),\n        offset: Math.round(node.y() - box.y),\n        snap: \"start\"\n      }, {\n        guide: Math.round(box.y + box.height / 2),\n        offset: Math.round(node.y() - box.y - box.height / 2),\n        snap: \"center\"\n      }, {\n        guide: Math.round(box.y + box.height),\n        offset: Math.round(node.y() - box.y - box.height),\n        snap: \"end\"\n      }]\n    };\n  };\n\n  const getGuides = (lineGuideStops, itemBounds) => {\n    const resultV = [];\n    const resultH = [];\n    lineGuideStops.vertical.forEach(lineGuide => {\n      itemBounds.vertical.forEach(itemBound => {\n        const diff = Math.abs(lineGuide - itemBound.guide); // if the distance between guild line and object snap point is close we can consider this for snapping\n\n        if (diff < GUIDELINE_OFFSET) {\n          resultV.push({\n            lineGuide: lineGuide,\n            diff: diff,\n            snap: itemBound.snap,\n            offset: itemBound.offset\n          });\n        }\n      });\n    });\n    lineGuideStops.horizontal.forEach(lineGuide => {\n      itemBounds.horizontal.forEach(itemBound => {\n        const diff = Math.abs(lineGuide - itemBound.guide);\n\n        if (diff < GUIDELINE_OFFSET) {\n          resultH.push({\n            lineGuide: lineGuide,\n            diff: diff,\n            snap: itemBound.snap,\n            offset: itemBound.offset\n          });\n        }\n      });\n    });\n    const guides = []; // find closest snap\n\n    const minV = resultV.sort((a, b) => a.diff - b.diff)[0];\n    const minH = resultH.sort((a, b) => a.diff - b.diff)[0];\n\n    if (minV) {\n      guides.push({\n        lineGuide: minV.lineGuide,\n        offset: minV.offset,\n        orientation: \"V\",\n        snap: minV.snap\n      });\n    }\n\n    if (minH) {\n      guides.push({\n        lineGuide: minH.lineGuide,\n        offset: minH.offset,\n        orientation: \"H\",\n        snap: minH.snap\n      });\n    }\n\n    return guides;\n  };\n\n  const drawGuides = guides => {\n    guides.forEach(lg => {\n      if (lg.orientation === \"H\") {\n        const lines = new Konva.Line({\n          points: [-6000, lg.lineGuide, 6000, lg.lineGuide],\n          stroke: \"rgb(0, 161, 255)\",\n          strokeWidth: 1,\n          name: \"guid-line\",\n          dash: [4, 6]\n        });\n        $layer.current.add(lines);\n        $layer.current.batchDraw();\n      } else if (lg.orientation === \"V\") {\n        const lines = new Konva.Line({\n          points: [lg.lineGuide, -6000, lg.lineGuide, 6000],\n          stroke: \"rgb(0, 161, 255)\",\n          strokeWidth: 1,\n          name: \"guid-line\",\n          dash: [4, 6]\n        });\n        $layer.current.add(lines);\n        $layer.current.batchDraw();\n      }\n    });\n  };\n\n  const _onDragMove = e => {\n    const linesArray = $layer.current.find(\".guid-line\");\n\n    if (!!linesArray.length) {\n      linesArray.forEach(item => item.destroy());\n    }\n\n    const lineGuideStops = getLineGuideStops(e.target);\n    const itemBounds = getObjectSnappingEdges(e.target);\n    const guides = getGuides(lineGuideStops, itemBounds);\n\n    if (!guides.length) {\n      return;\n    }\n\n    drawGuides(guides);\n    guides.forEach(lg => {\n      switch (lg.snap) {\n        case \"start\":\n          {\n            switch (lg.orientation) {\n              case \"V\":\n                {\n                  e.target.x(lg.lineGuide + lg.offset);\n                  break;\n                }\n\n              case \"H\":\n                {\n                  e.target.y(lg.lineGuide + lg.offset);\n                  break;\n                }\n\n              default:\n                return;\n            }\n\n            break;\n          }\n\n        case \"center\":\n          {\n            switch (lg.orientation) {\n              case \"V\":\n                {\n                  e.target.x(lg.lineGuide + lg.offset);\n                  break;\n                }\n\n              case \"H\":\n                {\n                  e.target.y(lg.lineGuide + lg.offset);\n                  break;\n                }\n\n              default:\n                return;\n            }\n\n            break;\n          }\n\n        case \"end\":\n          {\n            switch (lg.orientation) {\n              case \"V\":\n                {\n                  e.target.x(lg.lineGuide + lg.offset);\n                  break;\n                }\n\n              case \"H\":\n                {\n                  e.target.y(lg.lineGuide + lg.offset);\n                  break;\n                }\n\n              default:\n                return;\n            }\n\n            break;\n          }\n\n        default:\n          return;\n      }\n    });\n  };\n\n  const _onDragEnd = e => {\n    const linesArray = $layer.current.find(\".guid-line\");\n\n    if (!!linesArray.length) {\n      linesArray.forEach(item => item.destroy());\n    }\n\n    $layer.current.batchDraw();\n  };\n\n  const checkDeselect = e => {\n    // deselect when clicked on empty area\n    const clickedOnEmpty = e.target === e.target.getStage();\n\n    if (clickedOnEmpty) {\n      unSelectAll();\n      $tr.current.nodes([]);\n      setNodes([]); // layerRef.current.remove(selectionRectangle);\n    }\n  };\n\n  const updateSelectionRect = () => {\n    const node = selectionRectRef.current;\n    node.setAttrs({\n      visible: selection.current.visible,\n      x: Math.min(selection.current.x1, selection.current.x2),\n      y: Math.min(selection.current.y1, selection.current.y2),\n      width: Math.abs(selection.current.x1 - selection.current.x2),\n      height: Math.abs(selection.current.y1 - selection.current.y2),\n      fill: \"rgba(0, 161, 255, 0.3)\"\n    });\n    node.getLayer().batchDraw();\n  };\n\n  const oldPos = React.useRef(null);\n\n  const onMouseDown = e => {\n    const isElement = e.target.findAncestor(\".elements-container\");\n    const isTransformer = e.target.findAncestor(\"Transformer\");\n\n    if (isElement || isTransformer) {\n      return;\n    }\n\n    const pos = e.target.getStage().getPointerPosition();\n    selection.current.visible = true;\n    selection.current.x1 = pos.x;\n    selection.current.y1 = pos.y;\n    selection.current.x2 = pos.x;\n    selection.current.y2 = pos.y;\n    updateSelectionRect();\n  };\n\n  const onMouseMove = e => {\n    if (!selection.current.visible) {\n      return;\n    }\n\n    const pos = e.target.getStage().getPointerPosition();\n    selection.current.x2 = pos.x;\n    selection.current.y2 = pos.y;\n    updateSelectionRect();\n  };\n\n  const onMouseUp = () => {\n    oldPos.current = null;\n\n    if (!selection.current.visible) {\n      return;\n    }\n\n    const selBox = selectionRectRef.current.getClientRect();\n    const elements = [];\n    $layer.current.find(\".object\").forEach(elementNode => {\n      const elBox = elementNode.getClientRect();\n\n      if (Konva.Util.haveIntersection(selBox, elBox)) {\n        elements.push(elementNode);\n      }\n    });\n    $tr.current.nodes(elements);\n    selection.current.visible = false; // disable click event\n\n    Konva.listenClickTap = false;\n    updateSelectionRect();\n  };\n\n  const onClickTap = e => {\n    // if we are selecting with rect, do nothing\n    if (selectionRectRef.current.visible()) {\n      return;\n    }\n\n    let stage = e.target.getStage();\n    let layer = $layer.current;\n    let tr = $tr.current; // if click on empty area - remove all selections\n\n    if (e.target === stage) {\n      unSelectAll();\n      setNodes([]);\n      tr.nodes([]);\n      layer.draw();\n      return;\n    } // do nothing if clicked NOT on our rectangles\n\n\n    if (!e.target.hasName(\".object\")) {\n      return;\n    } // do we pressed shift or ctrl?\n\n\n    const metaPressed = e.evt.shiftKey || e.evt.ctrlKey || e.evt.metaKey;\n    const isSelected = tr.nodes().indexOf(e.target) >= 0;\n\n    if (!metaPressed && !isSelected) {\n      // if no key pressed and the node is not selected\n      // select just one\n      tr.nodes([e.target]);\n    } else if (metaPressed && isSelected) {\n      // if we pressed keys and node was selected\n      // we need to remove it from selection:\n      const nodes = tr.nodes().slice(); // use slice to have new copy of array\n      // remove node from array\n\n      nodes.splice(nodes.indexOf(e.target), 1);\n      tr.nodes(nodes);\n    } else if (metaPressed && !isSelected) {\n      // add the node into selection\n      const nodes = tr.nodes().concat([e.target]);\n      tr.nodes(nodes);\n    }\n\n    layer.draw();\n  };\n\n  return __jsx(Stage, _extends({\n    ref: $stage,\n    onMouseDown: onMouseDown,\n    onMouseUp: onMouseUp,\n    onMouseMove: onMouseMove,\n    onTouchStart: checkDeselect,\n    onClick: onClickTap\n  }, stageDimensions, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 376,\n      columnNumber: 9\n    }\n  }), __jsx(Layer, {\n    ref: $layer,\n    onDragMove: _onDragMove,\n    onDragEnd: _onDragEnd,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 385,\n      columnNumber: 13\n    }\n  }, (_templateData$variati = templateData.variations[variationIndex].elements) === null || _templateData$variati === void 0 ? void 0 : _templateData$variati.map((elem, i) => {\n    if (elem.type === \"rectangle\") return __jsx(Rectangle, {\n      key: i,\n      shapeProps: elem,\n      onSelect: e => {\n        if (e.current !== undefined) {\n          let temp = nodesArray;\n          if (!nodesArray.includes(e.current)) temp.push(e.current);\n          setNodes(temp);\n          $tr.current.nodes(nodesArray);\n          $tr.current.nodes(nodesArray);\n          $tr.current.getLayer().batchDraw();\n        }\n\n        setSelectedId(elem.id);\n      } // onSelect={() => {\n      //     setSelectedId(rect.id)\n      // }}\n      ,\n      onEditClick: handleEditSelectedItem,\n      onChange: newAttrs => {\n        setTemplateData(prev => {\n          const index = prev.variations[variationIndex].elements.findIndex(item => item.id === elem.id);\n          prev.variations[variationIndex].elements[index] = newAttrs;\n        });\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 392,\n        columnNumber: 25\n      }\n    });\n    if (elem.type === \"circle\") return __jsx(UCircle, {\n      key: i,\n      shapeProps: elem,\n      onSelect: () => {\n        setSelectedId(elem.id);\n      },\n      onEditClick: handleEditSelectedItem,\n      onChange: newAttrs => {\n        setTemplateData(prev => {\n          const index = prev.variations[variationIndex].elements.findIndex(item => item.id === elem.id);\n          prev.variations[variationIndex].elements[index] = newAttrs;\n        });\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 420,\n        columnNumber: 25\n      }\n    });\n    if (elem.type === \"line\") return __jsx(ULine, {\n      key: i,\n      shapeProps: elem,\n      onSelect: () => {\n        setSelectedId(elem.id);\n      },\n      onEditClick: handleEditSelectedItem,\n      onChange: newAttrs => {\n        setTemplateData(prev => {\n          const index = prev.variations[variationIndex].elements.findIndex(item => item.id === elem.id);\n          prev.variations[variationIndex].elements[index] = newAttrs;\n        });\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 437,\n        columnNumber: 25\n      }\n    });\n    if (elem.type === \"polygon\") return __jsx(UPolygon, {\n      key: i,\n      shapeProps: elem,\n      onSelect: () => {\n        setSelectedId(elem.id);\n      },\n      onEditClick: handleEditSelectedItem,\n      onChange: newAttrs => {\n        setTemplateData(prev => {\n          const index = prev.variations[variationIndex].elements.findIndex(item => item.id === elem.id);\n          prev.variations[variationIndex].elements[index] = newAttrs;\n        });\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 454,\n        columnNumber: 25\n      }\n    });\n    if (elem.type === \"svg\") return __jsx(USvg, {\n      key: i,\n      svgProps: elem,\n      onSelect: () => {\n        setSelectedId(elem.id);\n      },\n      onEditClick: handleEditSelectedItem,\n      onChange: event => setTemplateData(prev => {\n        const svgIndex = prev.variations[variationIndex].elements.findIndex(svgItem => svgItem.id === elem.id);\n        prev.variations[variationIndex].elements[svgIndex] = _objectSpread(_objectSpread({}, prev.variations[variationIndex].elements[svgIndex]), JSON.parse(JSON.stringify(event.target.attrs)));\n      }),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 471,\n        columnNumber: 25\n      }\n    });\n    if (elem.type === \"image\") return __jsx(UImage, {\n      key: i,\n      imageProps: elem,\n      onSelect: () => {\n        setSelectedId(elem.id);\n      },\n      onChange: event => setTemplateData(prev => {\n        const imageIndex = prev.variations[variationIndex].elements.findIndex(img => img.id === elem.id);\n        prev.variations[variationIndex].elements[imageIndex] = _objectSpread(_objectSpread({}, prev.variations[variationIndex].elements[imageIndex]), JSON.parse(JSON.stringify(event.target.attrs)));\n      }),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 489,\n        columnNumber: 25\n      }\n    });\n    if (elem.type === \"text\") return __jsx(UText, {\n      key: i,\n      textProps: elem,\n      onSelect: () => {\n        setSelectedId(elem.id);\n      },\n      onEditClick: handleEditSelectedItem,\n      onChange: event => setTemplateData(prev => {\n        const txtIndex = prev.variations[variationIndex].elements.findIndex(txt => txt.id === elem.id);\n        prev.variations[variationIndex].elements[txtIndex] = _objectSpread({}, event.target.attrs);\n      }),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 506,\n        columnNumber: 25\n      }\n    });\n  }), (_templateData$variati2 = templateData.variations[variationIndex].elements) === null || _templateData$variati2 === void 0 ? void 0 : (_templateData$variati3 = _templateData$variati2.filter(item => item.type === \"text\")) === null || _templateData$variati3 === void 0 ? void 0 : _templateData$variati3.map((item, index) => __jsx(UText, {\n    key: index,\n    textProps: item,\n    onSelect: () => {\n      setSelectedId(item.id);\n    },\n    onEditClick: handleEditSelectedItem,\n    onChange: event => setTemplateData(prev => {\n      const txtIndex = prev.variations[variationIndex].elements.findIndex(txt => txt.id === item.id);\n      prev.variations[variationIndex].elements[txtIndex] = _objectSpread({}, event.target.attrs);\n    }),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 528,\n      columnNumber: 21\n    }\n  })), __jsx(TransformerComponent, {\n    id: `tr${selectedId}`,\n    $tr: $tr,\n    selectedShapeName: selectedId,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 541,\n      columnNumber: 17\n    }\n  }), __jsx(Rect, {\n    fill: \"rgba(0,0,255,0.5)\",\n    ref: selectionRectRef,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 546,\n      columnNumber: 17\n    }\n  })));\n};\n\nexport default MainStage;","map":{"version":3,"sources":["D:/dev/cardclan-backend/template-tool/src/components/DesignTool/MainStage/index.tsx"],"names":["React","useRef","useState","Stage","Layer","Rect","Rectangle","UCircle","UPolygon","ULine","USvg","UText","TransformerComponent","stageDimensions","UImage","MainStage","templateData","setTemplateData","variationIndex","selectedId","setSelectedId","unSelectAll","handleEditSelectedItem","GUIDELINE_OFFSET","$stage","$layer","$tr","selectionRectRef","selection","visible","x1","y1","x2","y2","nodesArray","setNodes","Konva","window","getLineGuideStops","skipShape","vertical","width","horizontal","height","current","find","forEach","guideItem","box","getClientRect","push","x","y","flat","getObjectSnappingEdges","node","guide","Math","round","offset","snap","getGuides","lineGuideStops","itemBounds","resultV","resultH","lineGuide","itemBound","diff","abs","guides","minV","sort","a","b","minH","orientation","drawGuides","lg","lines","Line","points","stroke","strokeWidth","name","dash","add","batchDraw","_onDragMove","e","linesArray","length","item","destroy","target","_onDragEnd","checkDeselect","clickedOnEmpty","getStage","nodes","updateSelectionRect","setAttrs","min","fill","getLayer","oldPos","onMouseDown","isElement","findAncestor","isTransformer","pos","getPointerPosition","onMouseMove","onMouseUp","selBox","elements","elementNode","elBox","Util","haveIntersection","listenClickTap","onClickTap","stage","layer","tr","draw","hasName","metaPressed","evt","shiftKey","ctrlKey","metaKey","isSelected","indexOf","slice","splice","concat","variations","map","elem","i","type","undefined","temp","includes","id","newAttrs","prev","index","findIndex","event","svgIndex","svgItem","JSON","parse","stringify","attrs","imageIndex","img","txtIndex","txt","filter"],"mappings":"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","sourcesContent":["import React, { useRef, useState } from 'react'\r\nimport { Stage, Layer, Rect } from 'react-konva';\r\nimport Rectangle from \"../Rectangle\"\r\nimport UCircle from \"../UCircle\"\r\nimport UPolygon from \"../UPolygon\"\r\nimport ULine from \"../ULine\"\r\nimport USvg from \"../USvg\"\r\nimport UText from \"../UText\"\r\nimport TransformerComponent from \"../UTransformer\"\r\nimport { stageDimensions } from '../../../utils/defaults';\r\nimport UImage from '../UImage';\r\n\r\ndeclare const window: any\r\n\r\nconst MainStage = ({\r\n    templateData,\r\n    setTemplateData,\r\n    variationIndex,\r\n    selectedId,\r\n    setSelectedId,\r\n    unSelectAll,\r\n    handleEditSelectedItem,\r\n}) => {\r\n\r\n    const GUIDELINE_OFFSET = 5\r\n    const $stage = useRef(null)\r\n    const $layer = useRef(null)\r\n    const $tr = useRef(null)\r\n    const selectionRectRef = useRef(null);\r\n    const selection = useRef({\r\n        visible: false,\r\n        x1: 0,\r\n        y1: 0,\r\n        x2: 0,\r\n        y2: 0\r\n    });\r\n\r\n    const [nodesArray, setNodes] = useState([]);\r\n    const Konva = window.Konva;\r\n\r\n    const getLineGuideStops = skipShape => {\r\n        const vertical: any = [0, stageDimensions.width / 2, stageDimensions.width];\r\n        const horizontal: any = [0, stageDimensions.height / 2, stageDimensions.height];\r\n\r\n        // and we snap over edges and center of each object on the canvas\r\n        $stage.current.find(\".object\").forEach(guideItem => {\r\n            if (guideItem === skipShape) {\r\n                return;\r\n            }\r\n            const box = guideItem.getClientRect();\r\n            // and we can snap to all edges of shapes\r\n            vertical.push([box.x, box.x + box.width, box.x + box.width / 2]);\r\n            horizontal.push([box.y, box.y + box.height, box.y + box.height / 2]);\r\n        });\r\n        return {\r\n            vertical: vertical.flat(),\r\n            horizontal: horizontal.flat()\r\n        };\r\n    };\r\n\r\n    const getObjectSnappingEdges = node => {\r\n        const box = node.getClientRect();\r\n\r\n        return {\r\n            vertical: [\r\n                {\r\n                    guide: Math.round(box.x),\r\n                    offset: Math.round(node.x() - box.x),\r\n                    snap: \"start\"\r\n                },\r\n                {\r\n                    guide: Math.round(box.x + box.width / 2),\r\n                    offset: Math.round(node.x() - box.x - box.width / 2),\r\n                    snap: \"center\"\r\n                },\r\n                {\r\n                    guide: Math.round(box.x + box.width),\r\n                    offset: Math.round(node.x() - box.x - box.width),\r\n                    snap: \"end\"\r\n                }\r\n            ],\r\n            horizontal: [\r\n                {\r\n                    guide: Math.round(box.y),\r\n                    offset: Math.round(node.y() - box.y),\r\n                    snap: \"start\"\r\n                },\r\n                {\r\n                    guide: Math.round(box.y + box.height / 2),\r\n                    offset: Math.round(node.y() - box.y - box.height / 2),\r\n                    snap: \"center\"\r\n                },\r\n                {\r\n                    guide: Math.round(box.y + box.height),\r\n                    offset: Math.round(node.y() - box.y - box.height),\r\n                    snap: \"end\"\r\n                }\r\n            ]\r\n        };\r\n    };\r\n\r\n    const getGuides = (lineGuideStops, itemBounds) => {\r\n        const resultV = [];\r\n        const resultH = [];\r\n\r\n        lineGuideStops.vertical.forEach(lineGuide => {\r\n            itemBounds.vertical.forEach(itemBound => {\r\n                const diff = Math.abs(lineGuide - itemBound.guide);\r\n                // if the distance between guild line and object snap point is close we can consider this for snapping\r\n                if (diff < GUIDELINE_OFFSET) {\r\n                    resultV.push({\r\n                        lineGuide: lineGuide,\r\n                        diff: diff,\r\n                        snap: itemBound.snap,\r\n                        offset: itemBound.offset\r\n                    });\r\n                }\r\n            });\r\n        });\r\n\r\n        lineGuideStops.horizontal.forEach(lineGuide => {\r\n            itemBounds.horizontal.forEach(itemBound => {\r\n                const diff = Math.abs(lineGuide - itemBound.guide);\r\n                if (diff < GUIDELINE_OFFSET) {\r\n                    resultH.push({\r\n                        lineGuide: lineGuide,\r\n                        diff: diff,\r\n                        snap: itemBound.snap,\r\n                        offset: itemBound.offset\r\n                    });\r\n                }\r\n            });\r\n        });\r\n\r\n        const guides = [];\r\n\r\n        // find closest snap\r\n        const minV = resultV.sort((a, b) => a.diff - b.diff)[0];\r\n        const minH = resultH.sort((a, b) => a.diff - b.diff)[0];\r\n        if (minV) {\r\n            guides.push({\r\n                lineGuide: minV.lineGuide,\r\n                offset: minV.offset,\r\n                orientation: \"V\",\r\n                snap: minV.snap\r\n            });\r\n        }\r\n        if (minH) {\r\n            guides.push({\r\n                lineGuide: minH.lineGuide,\r\n                offset: minH.offset,\r\n                orientation: \"H\",\r\n                snap: minH.snap\r\n            });\r\n        }\r\n        return guides;\r\n    };\r\n\r\n    const drawGuides = guides => {\r\n        guides.forEach(lg => {\r\n            if (lg.orientation === \"H\") {\r\n                const lines = new Konva.Line({\r\n                    points: [-6000, lg.lineGuide, 6000, lg.lineGuide],\r\n                    stroke: \"rgb(0, 161, 255)\",\r\n                    strokeWidth: 1,\r\n                    name: \"guid-line\",\r\n                    dash: [4, 6]\r\n                });\r\n                $layer.current.add(lines);\r\n                $layer.current.batchDraw();\r\n            } else if (lg.orientation === \"V\") {\r\n                const lines = new Konva.Line({\r\n                    points: [lg.lineGuide, -6000, lg.lineGuide, 6000],\r\n                    stroke: \"rgb(0, 161, 255)\",\r\n                    strokeWidth: 1,\r\n                    name: \"guid-line\",\r\n                    dash: [4, 6]\r\n                });\r\n                $layer.current.add(lines);\r\n                $layer.current.batchDraw();\r\n            }\r\n        });\r\n    };\r\n\r\n    const _onDragMove = e => {\r\n        const linesArray = $layer.current.find(\".guid-line\")\r\n        if (!!linesArray.length) {\r\n            linesArray.forEach(item => item.destroy())\r\n        }\r\n        const lineGuideStops = getLineGuideStops(e.target);\r\n        const itemBounds = getObjectSnappingEdges(e.target);\r\n        const guides = getGuides(lineGuideStops, itemBounds);\r\n        if (!guides.length) {\r\n            return;\r\n        }\r\n        drawGuides(guides);\r\n        guides.forEach(lg => {\r\n            switch (lg.snap) {\r\n                case \"start\": {\r\n                    switch (lg.orientation) {\r\n                        case \"V\": {\r\n                            e.target.x(lg.lineGuide + lg.offset);\r\n                            break;\r\n                        }\r\n                        case \"H\": {\r\n                            e.target.y(lg.lineGuide + lg.offset);\r\n                            break;\r\n                        }\r\n                        default:\r\n                            return;\r\n                    }\r\n                    break;\r\n                }\r\n                case \"center\": {\r\n                    switch (lg.orientation) {\r\n                        case \"V\": {\r\n                            e.target.x(lg.lineGuide + lg.offset);\r\n                            break;\r\n                        }\r\n                        case \"H\": {\r\n                            e.target.y(lg.lineGuide + lg.offset);\r\n                            break;\r\n                        }\r\n                        default:\r\n                            return;\r\n                    }\r\n                    break;\r\n                }\r\n                case \"end\": {\r\n                    switch (lg.orientation) {\r\n                        case \"V\": {\r\n                            e.target.x(lg.lineGuide + lg.offset);\r\n                            break;\r\n                        }\r\n                        case \"H\": {\r\n                            e.target.y(lg.lineGuide + lg.offset);\r\n                            break;\r\n                        }\r\n                        default:\r\n                            return;\r\n                    }\r\n                    break;\r\n                }\r\n                default:\r\n                    return;\r\n            }\r\n        });\r\n    };\r\n\r\n    const _onDragEnd = e => {\r\n        const linesArray = $layer.current.find(\".guid-line\")\r\n        if (!!linesArray.length) {\r\n            linesArray.forEach(item => item.destroy())\r\n        }\r\n        $layer.current.batchDraw();\r\n    };\r\n\r\n    const checkDeselect = (e) => {\r\n        // deselect when clicked on empty area\r\n        const clickedOnEmpty = e.target === e.target.getStage();\r\n        if (clickedOnEmpty) {\r\n            unSelectAll();\r\n            $tr.current.nodes([]);\r\n            setNodes([]);\r\n            // layerRef.current.remove(selectionRectangle);\r\n        }\r\n    };\r\n\r\n    const updateSelectionRect = () => {\r\n        const node = selectionRectRef.current;\r\n        node.setAttrs({\r\n            visible: selection.current.visible,\r\n            x: Math.min(selection.current.x1, selection.current.x2),\r\n            y: Math.min(selection.current.y1, selection.current.y2),\r\n            width: Math.abs(selection.current.x1 - selection.current.x2),\r\n            height: Math.abs(selection.current.y1 - selection.current.y2),\r\n            fill: \"rgba(0, 161, 255, 0.3)\"\r\n        });\r\n        node.getLayer().batchDraw();\r\n    };\r\n\r\n    const oldPos = React.useRef(null);\r\n    const onMouseDown = (e) => {\r\n        const isElement = e.target.findAncestor(\".elements-container\");\r\n        const isTransformer = e.target.findAncestor(\"Transformer\");\r\n        if (isElement || isTransformer) {\r\n            return;\r\n        }\r\n\r\n        const pos = e.target.getStage().getPointerPosition();\r\n        selection.current.visible = true;\r\n        selection.current.x1 = pos.x;\r\n        selection.current.y1 = pos.y;\r\n        selection.current.x2 = pos.x;\r\n        selection.current.y2 = pos.y;\r\n        updateSelectionRect();\r\n    };\r\n\r\n    const onMouseMove = (e) => {\r\n        if (!selection.current.visible) {\r\n            return;\r\n        }\r\n        const pos = e.target.getStage().getPointerPosition();\r\n        selection.current.x2 = pos.x;\r\n        selection.current.y2 = pos.y;\r\n        updateSelectionRect();\r\n    };\r\n\r\n    const onMouseUp = () => {\r\n        oldPos.current = null;\r\n        if (!selection.current.visible) {\r\n            return;\r\n        }\r\n        const selBox = selectionRectRef.current.getClientRect();\r\n\r\n        const elements = [];\r\n        $layer.current.find(\".object\").forEach((elementNode) => {\r\n            const elBox = elementNode.getClientRect();\r\n            if (Konva.Util.haveIntersection(selBox, elBox)) {\r\n                elements.push(elementNode);\r\n            }\r\n        });\r\n        $tr.current.nodes(elements);\r\n        selection.current.visible = false;\r\n        // disable click event\r\n        Konva.listenClickTap = false;\r\n        updateSelectionRect();\r\n    };\r\n\r\n    const onClickTap = (e) => {\r\n        // if we are selecting with rect, do nothing\r\n        if (selectionRectRef.current.visible()) {\r\n            return;\r\n        }\r\n        let stage = e.target.getStage();\r\n        let layer = $layer.current;\r\n        let tr = $tr.current;\r\n        // if click on empty area - remove all selections\r\n        if (e.target === stage) {\r\n            unSelectAll();\r\n            setNodes([]);\r\n            tr.nodes([]);\r\n            layer.draw();\r\n            return;\r\n        }\r\n\r\n        // do nothing if clicked NOT on our rectangles\r\n        if (!e.target.hasName(\".object\")) {\r\n            return;\r\n        }\r\n\r\n        // do we pressed shift or ctrl?\r\n        const metaPressed = e.evt.shiftKey || e.evt.ctrlKey || e.evt.metaKey;\r\n        const isSelected = tr.nodes().indexOf(e.target) >= 0;\r\n\r\n        if (!metaPressed && !isSelected) {\r\n            // if no key pressed and the node is not selected\r\n            // select just one\r\n            tr.nodes([e.target]);\r\n        } else if (metaPressed && isSelected) {\r\n            // if we pressed keys and node was selected\r\n            // we need to remove it from selection:\r\n            const nodes = tr.nodes().slice(); // use slice to have new copy of array\r\n            // remove node from array\r\n            nodes.splice(nodes.indexOf(e.target), 1);\r\n            tr.nodes(nodes);\r\n        } else if (metaPressed && !isSelected) {\r\n            // add the node into selection\r\n            const nodes = tr.nodes().concat([e.target]);\r\n            tr.nodes(nodes);\r\n        }\r\n        layer.draw();\r\n    };\r\n\r\n    return (\r\n        <Stage\r\n            ref={$stage}\r\n            onMouseDown={onMouseDown}\r\n            onMouseUp={onMouseUp}\r\n            onMouseMove={onMouseMove}\r\n            onTouchStart={checkDeselect}\r\n            onClick={onClickTap}\r\n            {...stageDimensions}\r\n        >\r\n            <Layer\r\n                ref={$layer}\r\n                onDragMove={_onDragMove}\r\n                onDragEnd={_onDragEnd}\r\n            >\r\n                {templateData.variations[variationIndex].elements?.map((elem, i) => {\r\n                    if (elem.type === \"rectangle\") return (\r\n                        <Rectangle\r\n                            key={i}\r\n                            shapeProps={elem}\r\n                            onSelect={(e) => {\r\n                                if (e.current !== undefined) {\r\n                                    let temp = nodesArray;\r\n                                    if (!nodesArray.includes(e.current)) temp.push(e.current);\r\n                                    setNodes(temp);\r\n                                    $tr.current.nodes(nodesArray);\r\n                                    $tr.current.nodes(nodesArray);\r\n                                    $tr.current.getLayer().batchDraw();\r\n                                }\r\n                                setSelectedId(elem.id);\r\n                            }}\r\n                            // onSelect={() => {\r\n                            //     setSelectedId(rect.id)\r\n                            // }}\r\n                            onEditClick={handleEditSelectedItem}\r\n                            onChange={(newAttrs) => {\r\n                                setTemplateData((prev) => {\r\n                                    const index = prev.variations[variationIndex].elements.findIndex(item => item.id === elem.id)\r\n                                    prev.variations[variationIndex].elements[index] = newAttrs\r\n                                });\r\n                            }}\r\n                        />\r\n                    )\r\n\r\n                    if (elem.type === \"circle\") return (\r\n                        <UCircle\r\n                            key={i}\r\n                            shapeProps={elem}\r\n                            onSelect={() => {\r\n                                setSelectedId(elem.id)\r\n                            }}\r\n                            onEditClick={handleEditSelectedItem}\r\n                            onChange={(newAttrs) => {\r\n                                setTemplateData((prev) => {\r\n                                    const index = prev.variations[variationIndex].elements.findIndex(item => item.id === elem.id)\r\n                                    prev.variations[variationIndex].elements[index] = newAttrs\r\n                                });\r\n                            }}\r\n                        />\r\n                    )\r\n\r\n                    if (elem.type === \"line\") return (\r\n                        <ULine\r\n                            key={i}\r\n                            shapeProps={elem}\r\n                            onSelect={() => {\r\n                                setSelectedId(elem.id)\r\n                            }}\r\n                            onEditClick={handleEditSelectedItem}\r\n                            onChange={(newAttrs) => {\r\n                                setTemplateData((prev) => {\r\n                                    const index = prev.variations[variationIndex].elements.findIndex(item => item.id === elem.id)\r\n                                    prev.variations[variationIndex].elements[index] = newAttrs\r\n                                });\r\n                            }}\r\n                        />\r\n                    )\r\n\r\n                    if (elem.type === \"polygon\") return (\r\n                        <UPolygon\r\n                            key={i}\r\n                            shapeProps={elem}\r\n                            onSelect={() => {\r\n                                setSelectedId(elem.id)\r\n                            }}\r\n                            onEditClick={handleEditSelectedItem}\r\n                            onChange={(newAttrs) => {\r\n                                setTemplateData((prev) => {\r\n                                    const index = prev.variations[variationIndex].elements.findIndex(item => item.id === elem.id)\r\n                                    prev.variations[variationIndex].elements[index] = newAttrs\r\n                                });\r\n                            }}\r\n                        />\r\n                    )\r\n\r\n                    if (elem.type === \"svg\") return (\r\n                        <USvg\r\n                            key={i}\r\n                            svgProps={elem}\r\n                            onSelect={() => {\r\n                                setSelectedId(elem.id)\r\n                            }}\r\n                            onEditClick={handleEditSelectedItem}\r\n                            onChange={(event) => setTemplateData((prev) => {\r\n                                const svgIndex = prev.variations[variationIndex].elements.findIndex(svgItem => svgItem.id === elem.id)\r\n                                prev.variations[variationIndex].elements[svgIndex] = {\r\n                                    ...prev.variations[variationIndex].elements[svgIndex],\r\n                                    ...JSON.parse(JSON.stringify(event.target.attrs))\r\n                                }\r\n                            })}\r\n                        />\r\n                    )\r\n\r\n                    if (elem.type === \"image\") return (\r\n                        <UImage\r\n                            key={i}\r\n                            imageProps={elem}\r\n                            onSelect={() => {\r\n                                setSelectedId(elem.id)\r\n                            }}\r\n                            onChange={(event) => setTemplateData((prev) => {\r\n                                const imageIndex = prev.variations[variationIndex].elements.findIndex(img => img.id === elem.id)\r\n                                prev.variations[variationIndex].elements[imageIndex] = {\r\n                                    ...prev.variations[variationIndex].elements[imageIndex],\r\n                                    ...JSON.parse(JSON.stringify(event.target.attrs))\r\n                                }\r\n                            })}\r\n                        />\r\n                    )\r\n\r\n                    if (elem.type === \"text\") return (\r\n                        <UText\r\n                            key={i}\r\n                            textProps={elem}\r\n                            onSelect={() => {\r\n                                setSelectedId(elem.id)\r\n                            }}\r\n                            onEditClick={handleEditSelectedItem}\r\n                            onChange={(event) => setTemplateData((prev) => {\r\n                                const txtIndex = prev.variations[variationIndex].elements.findIndex(txt => txt.id === elem.id)\r\n                                prev.variations[variationIndex].elements[txtIndex] = { ...event.target.attrs }\r\n                            })}\r\n                        />\r\n                    )\r\n\r\n\r\n                })}\r\n\r\n\r\n\r\n\r\n\r\n                {templateData.variations[variationIndex].elements?.filter(item => item.type === \"text\")?.map((item, index) => (\r\n                    <UText\r\n                        key={index}\r\n                        textProps={item}\r\n                        onSelect={() => {\r\n                            setSelectedId(item.id)\r\n                        }}\r\n                        onEditClick={handleEditSelectedItem}\r\n                        onChange={(event) => setTemplateData((prev) => {\r\n                            const txtIndex = prev.variations[variationIndex].elements.findIndex(txt => txt.id === item.id)\r\n                            prev.variations[variationIndex].elements[txtIndex] = { ...event.target.attrs }\r\n                        })}\r\n                    />\r\n                ))}\r\n                <TransformerComponent\r\n                    id={`tr${selectedId}`}\r\n                    $tr={$tr}\r\n                    selectedShapeName={selectedId}\r\n                />\r\n                <Rect fill=\"rgba(0,0,255,0.5)\" ref={selectionRectRef} />\r\n            </Layer>\r\n        </Stage>\r\n    )\r\n}\r\n\r\nexport default MainStage\r\n"]},"metadata":{},"sourceType":"module"}