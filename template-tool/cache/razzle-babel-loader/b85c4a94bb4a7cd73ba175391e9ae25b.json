{"ast":null,"code":"const _excluded = [\"patternImageUrl\"];\nvar _jsxFileName = \"D:\\\\dev\\\\cardclan-backend\\\\template-tool\\\\src\\\\components\\\\DesignTool\\\\Rectangle.tsx\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React, { useRef } from 'react';\nimport { Rect } from 'react-konva';\nimport useImage from \"use-image\";\n\nconst Rectangle = ({\n  shapeProps,\n  onSelect,\n  onChange,\n  onEditClick\n}) => {\n  const shapeRef = useRef(null);\n\n  const {\n    patternImageUrl\n  } = shapeProps,\n        restProps = _objectWithoutProperties(shapeProps, _excluded);\n\n  const [image] = useImage(patternImageUrl || null);\n  const rectWidth = restProps.width;\n  const rectHeight = restProps.height;\n  const imageWidth = image ? image.width : 10;\n  const imageHeight = image ? image.height : 10;\n  const patternScale = restProps.patternScale || Math.max(rectWidth / imageWidth, rectHeight / imageHeight);\n  return __jsx(React.Fragment, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 28,\n      columnNumber: 9\n    }\n  }, __jsx(Rect, _extends({\n    ref: shapeRef,\n    onClick: onSelect,\n    onTap: onSelect,\n    onDblClick: onEditClick,\n    onDblTap: onEditClick,\n    draggable: true,\n    strokeScaleEnabled: false,\n    onTransformEnd: e => {\n      // transformer is changing scale of the node\n      // and NOT its width or height\n      // but in the store we have only width and height\n      // to match the data better we will reset scale on transform end\n      const node = shapeRef.current;\n      const scaleX = node.scaleX();\n      const scaleY = node.scaleY(); // we will reset it back\n\n      node.scaleX(1);\n      node.scaleY(1);\n      onChange(_objectSpread(_objectSpread({}, shapeProps), {}, {\n        x: node.x(),\n        y: node.y(),\n        width: Math.max(node.width() * scaleX),\n        height: Math.max(node.height() * scaleY)\n      }));\n    },\n    onDragEnd: e => {\n      onChange(_objectSpread(_objectSpread({}, shapeProps), {}, {\n        x: e.target.x(),\n        y: e.target.y()\n      }));\n    }\n  }, restProps, {\n    fillPatternImage: image,\n    fillPatternOffset: {\n      x: 0,\n      y: 0\n    },\n    fillPatternScaleX: patternScale,\n    fillPatternScaleY: patternScale,\n    fillPatternRepeat: \"no-repeat\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 29,\n      columnNumber: 13\n    }\n  })));\n};\n\nexport default Rectangle;","map":{"version":3,"sources":["D:/dev/cardclan-backend/template-tool/src/components/DesignTool/Rectangle.tsx"],"names":["React","useRef","Rect","useImage","Rectangle","shapeProps","onSelect","onChange","onEditClick","shapeRef","patternImageUrl","restProps","image","rectWidth","width","rectHeight","height","imageWidth","imageHeight","patternScale","Math","max","e","node","current","scaleX","scaleY","x","y","target"],"mappings":"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","sourcesContent":["import React, { useRef } from 'react';\r\nimport { Rect } from 'react-konva';\r\nimport useImage from \"use-image\"\r\n\r\ninterface Props {\r\n    shapeProps: any\r\n    onSelect: any\r\n    onChange: any\r\n    onEditClick: any\r\n}\r\n\r\nconst Rectangle: React.FC<Props> = ({ shapeProps, onSelect, onChange, onEditClick }) => {\r\n\r\n    const shapeRef = useRef(null)\r\n\r\n    const { patternImageUrl, ...restProps } = shapeProps\r\n    const [image] = useImage(patternImageUrl || null)\r\n    const rectWidth = restProps.width;\r\n    const rectHeight = restProps.height;\r\n    const imageWidth = image ? image.width : 10;\r\n    const imageHeight = image ? image.height : 10;\r\n    const patternScale = restProps.patternScale || Math.max(\r\n        rectWidth / imageWidth,\r\n        rectHeight / imageHeight\r\n    );\r\n\r\n    return (\r\n        <React.Fragment>\r\n            <Rect\r\n                ref={shapeRef}\r\n                onClick={onSelect}\r\n                onTap={onSelect}\r\n                onDblClick={onEditClick}\r\n                onDblTap={onEditClick}\r\n                draggable\r\n                strokeScaleEnabled={false}\r\n                onTransformEnd={(e) => {\r\n                    // transformer is changing scale of the node\r\n                    // and NOT its width or height\r\n                    // but in the store we have only width and height\r\n                    // to match the data better we will reset scale on transform end\r\n                    const node = shapeRef.current;\r\n                    const scaleX = node.scaleX();\r\n                    const scaleY = node.scaleY();\r\n\r\n                    // we will reset it back\r\n                    node.scaleX(1);\r\n                    node.scaleY(1);\r\n                    onChange({\r\n                        ...shapeProps,\r\n                        x: node.x(),\r\n                        y: node.y(),\r\n                        width: Math.max(node.width() * scaleX),\r\n                        height: Math.max(node.height() * scaleY)\r\n                    });\r\n                }}\r\n                onDragEnd={(e) => {\r\n                    onChange({\r\n                        ...shapeProps,\r\n                        x: e.target.x(),\r\n                        y: e.target.y(),\r\n                    });\r\n                }}\r\n                {...restProps}\r\n                fillPatternImage={image}\r\n                fillPatternOffset={{ x: 0, y: 0 }}\r\n                fillPatternScaleX={patternScale}\r\n                fillPatternScaleY={patternScale}\r\n                fillPatternRepeat=\"no-repeat\"\r\n            />\r\n        </React.Fragment>\r\n    );\r\n};\r\nexport default Rectangle\r\n"]},"metadata":{},"sourceType":"module"}